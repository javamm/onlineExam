<exams>
	<exam>
		<question>
给出如下代码 : 
class Test{ 
private int m; 
public static void fun() { 
// some code... 
} } 
如何使成员变量 m  被函数 fun() 直接访问 ? 
		</question>
		<answer>3,</answer>
		<detail>fun为static,要直接访问的话，必须也要改成static</detail>
		<options>
			<option>将 private int m  改为 protected int m</option>
			<option>将 private int m  改为  public int m</option>
			<option>将 private int m  改为  static int m </option>
			<option>将 private int m  改为  int m</option>
		</options>
	</exam>
	<exam>
		<question>下面哪个函数是 public void example(){...} 的重载函数？</question>
		<answer>4,</answer>
		<detail>
			    overload,方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准
				override,父类与子类之间的多态性，对父类的函数进行重新定义。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 
		</detail>
		<options>
			<option>private void example( int m){...}</option>
			<option>public int example(){...} </option>
			<option>public void example2(){...}</option>
			<option>public int example ( int m, float f){...}</option>
		</options>
	</exam>
	<exam>
		<question>已知如下定义： String s = "story"; 
下面哪个表达式是合法的？</question>
		<answer>1,</answer>
		<detail></detail>
		<options>
			<option>s += "books";</option>
			<option>char c = s[1];</option>
			<option>int len = s.length;</option>
			<option>String t = 100;</option>
		</options>
	</exam>
	<exam>
		<question>Java中 main()函数的返回值是什么 ?</question>
		<answer>4,</answer>
		<detail></detail>
		<options>
			<option>String </option>
			<option>int </option>
			<option>char </option>
			<option>void</option>
		</options>
	</exam>
	<exam>
		<question>如下哪个字串在Java 中可作为自定义标识符？</question>
		<answer>1,</answer>
		<detail></detail>
		<options>
			<option>$number</option>
			<option>super </option>
			<option>3number</option>
			<option>#number</option>
		</options>
	</exam>
	<exam>
		<question>如下哪个不是 Java中有效的关键字？</question>
		<answer>2,</answer>
		<detail></detail>
		<options>
			<option>const</option>
			<option>NULL</option>
			<option>false</option>
			<option>this</option>
		</options>
	</exam>
	<exam>
		<question>如下哪个不是 Java 中正确的整数表示 ? </question>
		<answer>4,</answer>
		<detail></detail>
		<options>
			<option>22</option>
			<option>0x22</option>
			<option>022</option>
			<option>22H</option>
		</options>
	</exam>
	<exam>
		<question>下面的代码段中，执行之后 i和 j的值是什么 ?int i = 1; 
int j; 
j = i++;  </question>
		<answer>3,</answer>
		<detail></detail>
		<options>
			<option>1, 1</option>
			<option>1, 2</option>
			<option>2, 1</option>
			<option>2, 2 </option>
		</options>
	</exam>
	<exam>
		<question>下面句话是正确的 ? </question>
		<answer>1,</answer>
		<detail></detail>
		<options>
			<option><![CDATA[>>  是算术右移操作符]]></option>
			<option><![CDATA[<<  是算术右移操作符]]></option>
			<option><![CDATA[>>>  是算术右移操作符]]></option>
			<option><![CDATA[<<<  是算术右移操作符]]></option>
		</options>
	</exam>
	<exam>
		<question>下面哪个赋值语句不是合法的？</question>
		<answer>1,</answer>
		<detail></detail>
		<options>
			<option>float a = 2.0</option>
			<option>double b = 2.0</option>
			<option>int c = 2 </option>
			<option>long d = 2</option>
		</options>
	</exam>
	<exam>
		<question>下面哪个是 main() 函数的合法参数 ?</question>
		<answer>3,</answer>
		<detail></detail>
		<options>
			<option>char args[]</option>
			<option>char args[][]</option>
			<option>String arg[]</option>
			<option>String args</option>
		</options>
	</exam>
	<exam>
		<question>已知表达式 int m[] = {0, 1, 2, 3, 4, 5, 6 }; 
下面哪个表达式的值与数组最大下标数相等？</question>
		<answer>2,</answer>
		<detail></detail>
		<options>
			<option>m.length()</option>
			<option>m.length-1</option>
			<option>m.length()+1</option>
			<option>m.length+1</option>
		</options>
	</exam>
	<exam>
		<question>函数重载是指</question>
		<answer>1,</answer>
		<detail></detail>
		<options>
			<option>两个或两个以上的函数取相同的函数名，但形参的个数或类型不同 </option>
			<option>两个以上的函数取相同的名字和具有相同的参数个数，但形参的类型可以不同 </option>
			<option>两个以上的函数名字不同，但形参的个数或类型相同 </option>
			<option>两个以上的函数取相同的函数名，并且函数的返回类型相同</option>
		</options>
	</exam>
	<exam>
		<question>在异常处理中，如释放资源、关闭文件、关闭数据库等由_来完成</question>
		<answer>3,</answer>
		<detail></detail>
		<options>
			<option>try子句　 </option>
			<option>catch子句 </option>
			<option>finally子句</option>
			<option>throw子句</option>
		</options>
	</exam>
	<exam>
		<question>下面哪条语句定义了5个元素的数组</question>
		<answer>1,</answer>
		<detail></detail>
		<options>
			<option>int [] a={22,23,24,25,12} </option>
			<option>int a []=new int(5); </option>
			<option>int [5] array;</option>
			<option>int [] arr;</option>
		</options>
	</exam>
	<exam>
		<question>已知如下的命令执行  java MyTest a b c 请问哪个语句是正确的？</question>
		<answer>3,</answer>
		<detail></detail>
		<options>
			<option>args[0] = "MyTest a b c"</option>
			<option>args[0] = "MyTest"</option>
			<option>args[0] = "a" </option>
			<option>args[1]= 'c'</option>
		</options>
	</exam>
	<exam>
		<question>Applet类的直接父类是</question>
		<answer>4,</answer>
		<detail></detail>
		<options>
			<option>Component类</option>
			<option>Container类 </option>
			<option>Frame类</option>
			<option>Panel类</option>
		</options>
	</exam>
	<exam>
		<question>下面哪个语句不能定义一个字符变量</question>
		<answer>2,</answer>
		<detail></detail>
		<options>
			<option>char c1=’a’;</option>
			<option>char c2=”S”; </option>
			<option>char c4=97;</option>
			<option>char c3=’\u0041’;</option>
		</options>
	</exam>
	<exam>
		<question>构造方法何时被调用</question>
		<answer>2,</answer>
		<detail></detail>
		<options>
			<option>类定义时</option>
			<option>创建对象时 </option>
			<option>调用对象方法时</option>
			<option>使用对象的变量时</option>
		</options>
	</exam>
	<exam>
		<question>下面的表达式中正确的是</question>
		<answer>1,</answer>
		<detail></detail>
		<options>
			<option>String s=″你好″;int i=3;s+=i;</option>
			<option>String s=″你好″;int i=3;if(i==s){s+=i};  </option>
			<option>String s=″你好″;int i=3;s=i+s; </option>
			<option>String s=″你好″；int i=3;s=i+;</option>
		</options>
	</exam>
	<exam>
		<question>已知如下代码： 
public class Test 
{ 
long a[] = new long[10]; 
public static void main ( String arg[] ) { 
System.out.println ( a[6] ); 
} 
} 
请问哪个情况是正确的？</question>
		<answer>3,</answer>
		<detail></detail>
		<options>
			<option>输出为 null</option>
			<option>输出为 0</option>
			<option>编译时出错</option>
			<option>运行时出错</option>
		</options>
	</exam>
	<exam>
		<question>Frame的默认的布局管理器是下列哪一个</question>
		<answer>2,</answer>
		<detail></detail>
		<options>
			<option>FlowLayout</option>
			<option>BorderLayout </option>
			<option>GridLayout</option>
			<option>CardLayout </option>
		</options>
	</exam>
	<exam>
		<question>下列语句片段 
int a=10,b=4,c=20,d=6; System.out.println(a++*b+c*--d); 的结果为</question>
		<answer>3,</answer>
		<detail></detail>
		<options>
			<option>144</option>
			<option>28</option>
			<option>140</option>
			<option>不能执行 </option>
		</options>
	</exam>
	<exam>
		<question>对象使用时，下面描述错误的是</question>
		<answer>2,</answer>
		<detail></detail>
		<options>
			<option>通过“.”运算符调用成员变量和方法 </option>
			<option>通过成员变量的访问权限设定限制自身对这些变量方法的调用 </option>
			<option>将一个对象申明为类的成员时，必须在使用前为其分配内存 </option>
			<option>在方法中使用对象作为参数时，采用引用调用 </option>
		</options>
	</exam>
	<exam>
		<question>执行下列代码后，哪个结论是正确的String［］ s=new String［10］;</question>
		<answer>2,</answer>
		<detail></detail>
		<options>
			<option>s［10］为″″</option>
			<option>s［9］为null</option>
			<option>s［0］为未定义</option>
			<option>s.length为101</option>
		</options>
	</exam>
	<exam>
		<question>Java编程所必须的默认引用包为</question>
		<answer>2,</answer>
		<detail></detail>
		<options>
			<option>java.sys包</option>
			<option>java.lang包</option>
			<option>java.new包</option>
			<option>以上都不是</option>
		</options>
	</exam>
	<exam>
		<question>定义一个类名为“MyClass.java”的类，并且该类可被一个工程中的所有类访问，那么该类的正确声明应为：</question>
		<answer>3,</answer>
		<detail></detail>
		<options>
			<option>private class MyClass extends Object </option>
			<option>class MyClass extends Object </option>
			<option>public class MyClass </option>
			<option>private class MyClass extends Object</option>
		</options>
	</exam>
	<exam>
		<question>以下哪个方法用于定义线程的执行体？</question>
		<answer>3,</answer>
		<detail></detail>
		<options>
			<option>start()</option>
			<option>init()</option>
			<option>run()</option>
			<option>main()</option>
			<option>synchronized()</option>
		</options>
	</exam>
	<exam>
		<question>如果类中的成员变量可以被同一包访问，则使用如下哪个约束符 ? </question>
		<answer>4,</answer>
		<detail></detail>
		<options>
			<option>private </option>
			<option>public </option>
			<option>protected </option>
			<option>缺省</option>
			<option>final</option>
		</options>
	</exam>
	<exam>
		<question>以下哪个约束符可用于定义成员常量？</question>
		<answer>2,</answer>
		<detail></detail>
		<options>
			<option>static </option>
			<option>final </option>
			<option>abstract  </option>
			<option>finally</option>
		</options>
	</exam>
	<exam>
		<question>当方法遇到异常又不知如何处理时，下列哪种说法是正确的</question>
		<answer>2,</answer>
		<detail></detail>
		<options>
			<option>捕获异常 </option>
			<option>抛出异常 </option>
			<option>声明异常 </option>
			<option>嵌套异常</option>
		</options>
	</exam>
	<exam>
		<question>下列不属于容器的是</question>
		<answer>2,</answer>
		<detail></detail>
		<options>
			<option>Window</option>
			<option>TextBox </option>
			<option>Panel</option>
			<option>ScrollPane</option>
		</options>
	</exam>
	<exam>
		<question>当 Frame 改变大小时，放在其中的按钮大小不变，则使用如下哪个 layout? </question>
		<answer>1,</answer>
		<detail></detail>
		<options>
			<option>FlowLayout  </option>
			<option>CardLayout  </option>
			<option>BorderLayout  </option>
			<option>GridLayout </option>
		</options>
	</exam>
	<exam>
		<question>监听器接口的方法返回值是什么？</question>
		<answer>3,</answer>
		<detail></detail>
		<options>
			<option>int  </option>
			<option>String  </option>
			<option>void  </option>
			<option>Object </option>
		</options>
	</exam>
	<exam>
		<question>下面哪个方法与 applet 的显示无关 ?</question>
		<answer>2,</answer>
		<detail></detail>
		<options>
			<option>update() </option>
			<option>draw() </option>
			<option>repaint() </option>
			<option>paint()</option>
		</options>
	</exam>
	<exam>
		<question>下面哪个不是 Java 中的容器 ?</question>
		<answer>2,</answer>
		<detail></detail>
		<options>
			<option>ScrollPane   </option>
			<option>Canvas  </option>
			<option>Dialog      </option>
			<option>Applet </option>
		</options>
	</exam>
	<exam>
		<question>在Java中，属于整数类型变量的是</question>
		<answer>3,</answer>
		<detail></detail>
		<options>
			<option>single  </option>
			<option>double  </option>
			<option>byte </option>
			<option>char</option>
		</options>
	</exam>
	<exam>
		<question>下面哪个描述是正确的</question>
		<answer>3,</answer>
		<detail></detail>
		<options>
			<option>Applet程序中不需要main()方法，也不能有 </option>
			<option>Application程序中可以没有main()方法 </option>
			<option>Applet程序中可以不定义init( )方法 </option>
			<option>Application程序中必须有run( )方法</option>
		</options>
	</exam>
	<exam>
		<question>下列哪个方法可用于创建一个可运行的类</question>
		<answer>1,</answer>
		<detail></detail>
		<options>
			<option>public class X implements Runable{ public void run(){......} }  </option>
			<option>public class X implements Thread{ public void run(){......} }  </option>
			<option>public class X implements Thread{ public int run(){......} } </option>
			<option>public class X implements Runable{ protected void run(){......} }</option>
		</options>
	</exam>
	<exam>
		<question>Which statement is true? </question>
		<answer>4,</answer>
		<detail>anonymous inner class can not declared with any modifyer. and can only implement one interface</detail>
		<options>
			<option>An anonymous inner class may be declared as final.  </option>
			<option>An anonymous inner class can be declared as private.  </option>
			<option>An anonymous inner class can implement multiple interfaces .  </option>
			<option>An anonymous inner class can access final variables in any enclosing scope</option>
			<option>Construction of an instance of a static inner class requires an instance of the enclosing outer class.</option>
		</options>
	</exam>
	<exam>
		<question>Which statement about static inner classes is true? </question>
		<answer>3,</answer>
		<detail>because static , it needn't instance of enclosing outer class and it's instance member need it's instance.</detail>
		<options>
			<option>An anonymous class can be declared as static  </option>
			<option>A static inner class cannot be a static member of the outer class  </option>
			<option>A static inner class does not require an instance of the enclosing class  </option>
			<option>Instance members of a static inner class can be referenced using the class name of the static inner class </option>
		</options>
	</exam>
	<exam>
		<question>
			<![CDATA[编译Java  Application 源程序文件将产生相应的字节码文件，这些字节码文件的扩展名为]]>
		</question>
		<answer>2,</answer>
		<detail>
			<![CDATA[]]>
		</detail>
		<options>
			<option><![CDATA[.java]]></option>
			<option><![CDATA[.class]]></option>
			<option><![CDATA[.html]]></option>
			<option><![CDATA[.exe]]></option>
		</options>
	</exam>
	<exam>
		<question>
			<![CDATA[main方法是Java  Application程序执行的入口点，关于main方法的方法头以下哪项是合法的]]>
		</question>
		<answer>2,</answer>
		<detail>
			<![CDATA[]]>
		</detail>
		<options>
			<option><![CDATA[public static void main()]]></option>
			<option><![CDATA[public static void main( String args[] )]]></option>
			<option><![CDATA[public static int main( String [] args )]]></option>
			<option><![CDATA[public void main( String  args[] )]]></option>
		</options>
	</exam>
	<exam>
		<question>
			<![CDATA[以下哪项关键字能够作为Interface内定义的Method的修饰符？]]>
		</question>
		<answer>1,3,</answer>
		<detail>
			<![CDATA[]]>
		</detail>
		<options>
			<option><![CDATA[public]]></option>
			<option><![CDATA[final]]></option>
			<option><![CDATA[abstract]]></option>
			<option><![CDATA[protected]]></option>
		</options>
	</exam>
	<exam>
		<question>
			<![CDATA[一个函数定义的返回值是float，它不能在return语句中返回的值的类型是]]>
		</question>
		<answer>4,</answer>
		<detail>
			<![CDATA[]]>
		</detail>
		<options>
			<option><![CDATA[char]]></option>
			<option><![CDATA[float]]></option>
			<option><![CDATA[long]]></option>
			<option><![CDATA[double]]></option>
		</options>
	</exam>
	<exam>
		<question>
			<![CDATA[下面哪项是不合法的标识符：]]>
		</question>
		<answer>3,</answer>
		<detail>
			<![CDATA[]]>
		</detail>
		<options>
			<option><![CDATA[$persons]]></option>
			<option><![CDATA[TwoUsers]]></option>
			<option><![CDATA[*point]]></option>
			<option><![CDATA[_endline]]></option>
		</options>
	</exam>
	<exam>
		<question>
			<![CDATA[下面不属于JAVA关键字的是]]>
		</question>
		<answer>3,</answer>
		<detail>
			<![CDATA[]]>
		</detail>
		<options>
			<option><![CDATA[instanceof]]></option>
			<option><![CDATA[finally]]></option>
			<option><![CDATA[sizeof]]></option>
			<option><![CDATA[volatile]]></option>
		</options>
	</exam>
	<exam>
		<question><![CDATA[下面程序的输出为：
	public class ArrayTest{ 
		public static void main (String[] args){ 
			Object[] ov; 
		    String[] sa = { "Green", "Blue", "Red" }; 
    		ov = sa; 
    		System.out.println("Color=" + ov[1]); 
		} 
	}  ]]></question>
		<answer>2,</answer>
		<detail>
			<![CDATA[]]>
		</detail>
		<options>
			<option><![CDATA[存在编译错误]]></option>
			<option><![CDATA[输出Color=Blue]]></option>
			<option><![CDATA[输出Color=Green]]></option>
			<option><![CDATA[运行时抛出异常]]></option>
		</options>
	</exam>
	<exam>
		<question><![CDATA[字符串t中的字符为
			String s = "hypertext"; 
			String t = s.substring(2, 5); ]]></question>
		<answer>4,</answer>
		<detail>
			<![CDATA[]]>
		</detail>
		<options>
			<option><![CDATA["yper"]]></option>
			<option><![CDATA["ype"]]></option>
			<option><![CDATA["pert"]]></option>
			<option><![CDATA["per"]]></option>
		</options>
	</exam>
	<exam>
		<question><![CDATA[有如下程序，请选择一个正确的结果
				class Superclass { } 
				class Subclass extends Superclass { }
				Superclass a = new Superclass(); 
				Subclass b = new Subclass();
				选择一个正确的来解释下面的语句：b = a; ]]></question>
		<answer>1,</answer>
		<detail><![CDATA[]]></detail>
		<options>
			<option><![CDATA[编译非法]]></option>
			<option><![CDATA[编译正确，但运行时可能非法]]></option>
			<option><![CDATA[运行时正确]]></option>
		</options>
	</exam>
	<exam>
		<question><![CDATA[以下那些判断会返回 false
	String a = “Hello”;
	String b = “Hello”;
	String c = new String(“Hello”);]]></question>
		<answer>3,</answer>
		<detail><![CDATA[]]></detail>
		<options>
			<option><![CDATA[a.equals(b);]]></option>
			<option><![CDATA[a == b;两个是同一个对象]]></option>
			<option><![CDATA[a == c;]]></option>
			<option><![CDATA[c.equals(“Hello”);]]></option>
		</options>
	</exam>
	<exam>
		<question><![CDATA[对于以下的方法体，如果TimedOutException直接继承Exception类，那么哪一个方法声明适合以下的方法体代码？
	{ 
	success = connect();
	　　if (success = = 1)
	{
	throw new TimedOutException();
	}
	}]]></question>
		<answer>3,</answer>
		<detail><![CDATA[]]></detail>
		<options>
			<option><![CDATA[public void method()]]></option>
			<option><![CDATA[public void method() throws Exception]]></option>
			<option><![CDATA[public void method() throw TimedOutException]]></option>
			<option><![CDATA[public throw TimedOutException void method()]]></option>
		</options>
	</exam>
	<exam>
		<question><![CDATA[如果需要把一个对象作为key添加到HashMap中，那么该对象至少需要重载Object的哪些方法]]></question>
		<answer>4,</answer>
		<detail><![CDATA[]]></detail>
		<options>
			<option><![CDATA[clone和equals]]></option>
			<option><![CDATA[hashCode和clone]]></option>
			<option><![CDATA[finalize和clone]]></option>
			<option><![CDATA[hashCode和equals]]></option>
		</options>
	</exam>
	<exam>
		<question><![CDATA[请问以下陈述那项是正确的]]></question>
		<answer>2,</answer>
		<detail><![CDATA[]]></detail>
		<options>
			<option><![CDATA[当一个对象不可到达时，该对象可以被垃圾回收器回收]]></option>
			<option><![CDATA[只有当没有任何引用指向一个对象时，该对象才能够被回收]]></option>
			<option><![CDATA[一个对象的finalize方法可能被垃圾回收器多次调用]]></option>
			<option><![CDATA[finalize方法只能够被垃圾回收器调用]]></option>
		</options>
	</exam>
	<exam>
		<question><![CDATA[作用域public,private,protected,以及不写时的区别]]></question>
		<answer></answer>
		<detail><![CDATA[作用域 当前类 同一package 子孙类 其他package
	public √ √ √ √
	protected √ √ √ ×
	friendly √ √ × ×
	private √ × × ×
	不写时默认为friendly
	]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[	ArrayList和Vector的区别,HashMap和Hashtable的区别]]></question>
		<answer></answer>
		<detail><![CDATA[	就ArrayList与Vector主要从二方面来说.
	一.同步性:Vector是线程安全的，也就是说是同步的，而ArrayList是线程序不安全的，不是同步的
	二.数据增长:当需要增长时,Vector 默认增长为原来一培，而ArrayList却是原来的一半
	就HashMap与HashTable主要从三方面来说。
	一.历史原因:Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现
	二.同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的
	三.值：只有HashMap可以让你将空值作为一个表的条目的key或value]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[	char型变量中能不能存贮一个中文汉字?为什么?]]></question>
		<answer></answer>
		<detail><![CDATA[是能够定义成为一个中文的，因为java中以unicode编码，一个char占16个字节，所以放一个中文是没问题的]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[	多线程有几种实现方法,都是什么?同步有几种实现方法,都是什么?]]></question>
		<answer></answer>
		<detail><![CDATA[	线程有两种实现方法，分别是继承Thread类与实现Runnable接口
	同步的实现方面有两种，分别是synchronized,wait与notify]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[	float型float f=3.4是否正确?]]></question>
		<answer>2,</answer>
		<detail><![CDATA[	不正确。精度不准确,应该用强制类型转换，如下所示：float f=(float)3.4]]></detail>
		<options>
			<option><![CDATA[正确]]></option>
			<option><![CDATA[不正确]]></option>
		</options>
	</exam>
	<exam>
		<question><![CDATA[绍JAVA中的Collection FrameWork(包括如何写自己的数据结构)?]]></question>
		<answer></answer>
		<detail><![CDATA[	
	Collection
	├List
	│├LinkedList
	│├ArrayList
	│└Vector
	│　└Stack
	└Set
	Map
	├Hashtable
	├HashMap
	└WeakHashMap
	Collection是最基本的集合接口，一个Collection代表一组Object，即Collection的元素（Elements）
Map提供key到value的映射]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[STRING与STRINGBUFFER的区别]]></question>
		<answer></answer>
		<detail><![CDATA[STRING的长度是不可变的，STRINGBUFFER的长度是可变的。如果你对字符串中的内容经常进行操作，特别是内容要修改时，那么使用StringBuffer，如果最后需要String，那么使用StringBuffer的toString()方法]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[	jsp有哪些内置对象?作用分别是什么?]]></question>
		<answer></answer>
		<detail><![CDATA[	JSP共有以下9种基本内置组件（可与ASP的6种内部组件相对应）：
	　request 用户端请求，此请求会包含来自GET/POST请求的参数
	response 网页传回用户端的回应
	pageContext 网页的属性是在这里管理
	session 与请求有关的会话期
	application servlet 正在执行的内容
	out 用来传送回应的输出
	config servlet的构架部件
	page JSP网页本身
	exception 针对错误网页，未捕捉的例外]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[	jsp有哪些动作?作用分别是什么?]]></question>
		<answer></answer>
		<detail><![CDATA[	JSP共有以下6种基本动作
	jsp:include：在页面被请求的时候引入一个文件。
	Jsp:useBean：寻找或者实例化一个JavaBean。
	Jsp:setProperty：设置JavaBean的属性。
	Jsp:getProperty：输出某个JavaBean的属性。
	Jsp:forward：把请求转到一个新的页面。
Jsp:plugin：根据浏览器类型为Java插件生成OBJECT或EMBED标记]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[	JSP中动态INCLUDE与静态INCLUDE的区别？]]></question>
		<answer>3,</answer>
		<detail><![CDATA[	动态INCLUDE用jsp:include动作实现
	<jsp:include page="included.jsp" flush="true" />它总是会检查所含文件中的变化，适合用于包含动态页面，并且可以带参数
	静态INCLUDE用include伪码实现,定不会检查所含文件的变化，适用于包含静态页面
	<%@ include file="included.htm" %>]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[jsp的两种跳转方式分别是什么?有什么区别?]]></question>
		<answer></answer>
		<detail><![CDATA[	<jsp:include page="included.jsp" flush="true">
	<jsp:forward page= "nextpage.jsp"/>
	前者页面不会转向include所指的页面，只是显示该页的结果，主页面还是原来的页面。执行完后还会回来，相当于函数调用。并且可以带参数.后者完全转向新页面，不会再回来。相当于go to 语句。]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[	说一说Servlet的生命周期?]]></question>
		<answer></answer>
		<detail><![CDATA[servlet有良好的生存期的定义，包括加载和实例化、初始化、处理请求以及服务结束。这个生存期由javax.servlet.Servlet接口的init,service和destroy方法表达。]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[	JAVA SERVLET API中forward() 与redirect()的区别？]]></question>
		<answer></answer>
		<detail><![CDATA[前者仅是容器中控制权的转向，在客户端浏览器地址栏中不会显示出转向后的地址；后者则是完全的跳转，浏览器将会得到跳转的地址，并重新发送请求链接。这样，从浏览器的地址栏中可以看到跳转后的链接地址。所以，前者更加高效，在前者可以满足需要时，尽量使用forward()方法，并且，这样也有助于隐藏实际的链接。在有些情况下，比如，需要跳转到一个其它服务器上的资源，则必须使用sendRedirect()方法。]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[	xml有哪些解析技术?区别是什么?]]></question>
		<answer></answer>
		<detail><![CDATA[	有DOM,SAX,STAX等
	DOM: 处理大型文件时其性能下降的非常厉害。这个问题是由DOM的树结构所造成的，这种结构占用的内存较多，而且DOM必须在解析文件之前把整个文档装入内存, 适合对XML的随机访问SAX:不现于DOM,SAX是事件驱动型的XML解析方式。它顺序读取XML文件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过在其回调事件中写入处理代码来处理XML文件，适合对XML的顺序访问
	STAX:Streaming API for XML (StAX)]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[	EJB与JAVA BEAN的区别？]]></question>
		<answer></answer>
		<detail><![CDATA[Java Bean 是可复用的组件，对Java Bean并没有严格的规范，理论上讲，任何一个Java类都可以是一个Bean。但通常情况下，由于Java Bean是被容器所创建（如Tomcat)的，所以Java Bean应具有一个无参的构造器，另外，通常Java Bean还要实现Serializable接口用于实现Bean的持久性。Java Bean实际上相当于微软COM模型中的本地进程内COM组件，它是不能被跨进程访问的。Enterprise Java Bean 相当于DCOM，即分布式组件。它是基于Java的远程方法调用（RMI）技术的，所以EJB可以被远程访问（跨进程、跨计算机）。但EJB必须被布署在诸如Webspere、WebLogic这样的容器中，EJB客户从不直接访问真正的EJB组件，而是通过其容器访问。EJB容器是EJB组件的代理， EJB组件由容器所创建和管理。客户通过容器来访问真正的EJB组件。]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[	MVC的各个部分都有那些技术来实现?如何实现?]]></question>
		<answer></answer>
		<detail><![CDATA[ MVC是Model－View－Controller的简写。"Model" 代表的是应用的业务逻辑（通过JavaBean，EJB组件实现）， "View" 是应用的表示面（由JSP页面产生），"Controller" 是提供应用的处理过程控制（一般是一个Servlet），通过这种设计模型把应用逻辑，处理过程和显示逻辑分成不同的组件实现。这些组件可以进行交互和重用。]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[J2EE是什么？]]></question>
		<answer></answer>
		<detail><![CDATA[	Je22是Sun公司提出的多层(multi-diered),分布式(distributed),基于组件(component-base)的企业级应用模型(enterpriese application model).在这样的一个应用系统中，可按照功能划分为不同的组件，这些组件又可在不同计算机上，并且处于相应的层次(tier)中。所属层次包括客户层(clietn tier)组件,web层和组件,Business层和组件,企业信息系统(EIS)层。]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[	WEB SERVICE名词解释。JSWDL开发包的介绍。JAXP、JAXM的解释。SOAP、UDDI,WSDL解释。]]></question>
		<answer></answer>
		<detail><![CDATA[	Web Service描述语言WSDL
	SOAP即简单对象访问协议(Simple Object Access Protocol)，它是用于交换XML编码信息的轻量级协议。
	UDDI 的目的是为电子商务建立标准；UDDI是一套基于Web的、分布式的、为Web Service提供的、信息注册中心的实现标准规范，同时也包含一组使企业能将自身提供的Web Service注册，以使别的企业能够发现的访问协议的实现标准。]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[	开发中都用到了那些设计模式?用在什么场合?]]></question>
		<answer></answer>
		<detail><![CDATA[MVC模式，工厂方法模式，策略模式，代理模式，门面模式，单例模式，适配器模式，装饰器模式，命令模式]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[	LINUX下线程，GDI类的解释]]></question>
		<answer></answer>
		<detail><![CDATA[LINUX实现的就是基于核心轻量级进程的"一对一"线程模型，一个线程实体对应一个核心轻量级进程，而线程之间的管理在核外函数库中实现。
	GDI类为图像设备编程接口类库。]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[你让工人为你工作7天，回报是一根金条，这个金条平分成相连的7段，你必须在每天结束的时候给他们一段金条。如果只允许你两次把金条弄断，你如何给你的工人付费?]]></question>
		<answer></answer>
		<detail><![CDATA[分成1,2,4三段，第一天给1，第二天给2取回1，第3天给1，第4天给4取回1、2，第5天给1，第6天给2取回1，第七天给1]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[有一辆火车以每小时15公里的速度离开北京直奔广州，同时另一辆火车每小时20公里的速度从广州开往北京。如果有一只鸟，以30公里每小时的速度和两辆火车同时启动，从北京出发，碰到另一辆车后就向相反的方向返回去飞，就这样依次在两辆火车之间来回地飞，直到两辆火车相遇。请问，这只鸟共飞行了多长的距离?]]></question>
		<answer></answer>
		<detail><![CDATA[求出火车相遇时间，鸟速 * 时间=鸟飞行的距离]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[你有四个装药丸的罐子，每个药丸都有一定的重量，被污染的药丸是没被污染的药丸的重量+1。只称量一次，如何判断哪个罐子的药被污染了?]]></question>
		<answer></answer>
		<detail><![CDATA[第一个药瓶拿1个
第二个药瓶拿2个
第三个药瓶拿3个
第四个药瓶拿4个
计算标准的10颗药重量，与现在的10颗药比较
如果重量多1，就是第一个药瓶污染了
如果重量多2，就是第二个药瓶污染了
如果重量多3，就是第三个药瓶污染了
如果重量多4，就是第四个药瓶污染了 ]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[门外三个开关分别对应室内三盏灯，线路良好，在门外控制开关时候不能看到室内灯的情况，现在只允许进门一次，确定开关和灯的对应关系?]]></question>
		<answer></answer>
		<detail><![CDATA[三个开关分别：关，开，开1小时，然后进屋，暗且凉的为开关A控制的灯，亮的为开关B控制的灯，暗且热的为开关C控制的灯]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[人民币为什么只有1、2、5、10的面值?]]></question>
		<answer></answer>
		<detail><![CDATA[现在人民币还有20，50，100的大额面值，加上10，可组成10元以上的任意倍数。
因为用这四个数可以用最少的数组成1----10的任意数。
1=1
2=2
3=1+2
4=2+2
5=1+2+2
6=1+5
7=2+5
8=1+2+5
9=2+2+5
10=10
都不超过3张。]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[你有两个罐子以及50个红色弹球和50个蓝色弹球，随机选出一个罐子， 随机选出一个弹球放入罐子，怎么给出红色弹球最大的选中机会?在你的计划里，得到红球的几率是多少?]]></question>
		<answer></answer>
		<detail><![CDATA[一个罐子放一个红球,另一个罐子放49个红球和50个蓝球,概率接近75%.  这是所能达到的最大概率了]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[给你两颗6面色子，可以在它们各个面上刻上0-9任意一个数字，要求能够用它们拼出任意一年中的日期数值]]></question>
		<answer></answer>
		<detail><![CDATA[012345 0126(9)78      重点是 6倒过来就是9]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[烧一根不均匀的绳，从头烧到尾总共需要1个小时。现在有若干条材质相同的绳子，问如何用烧绳的方法来计时一个小时十五分钟呢？]]></question>
		<answer></answer>
		<detail><![CDATA[a绳从两头烧，同时b绳从一头烧，当a绳烧尽时，灭掉b绳，同时c绳从两头烧，在c绳烧尽时，b绳从两头烧，结束时即为1小时15分钟]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[你有一桶果冻，其中有黄色、绿色、红色三种，闭上眼睛抓取同种颜色的两个。抓取多少个就可以确定你肯定有两个同一颜色的果冻？]]></question>
		<answer></answer>
		<detail><![CDATA[抓2次  一共4个 就有2个必然相同的 ]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[如果你有无穷多的水，一个3公升的提捅，一个5公升的提捅，两只提捅形状上下都不均匀，问你如何才能准确称出4公升的水？]]></question>
		<answer></answer>
		<detail><![CDATA[1，用5升桶满桶，倒入3升桶中，倒满后大桶里剩2升；
2，把3升桶倒空，把那2升倒入3升桶中。
3，用5升桶满桶再向3升里倒，倒入一升就满，大桶里剩下的是4 升]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[一个岔路口分别通向诚实国和说谎国。来了两个人，已知一个是诚实国的，另一个是说谎国的。诚实国永远说实话，说谎国永远说谎话。现在你要去说谎国，但不知道应该走哪条路，需要问这两个人。请问应该怎么问？]]></question>
		<answer></answer>
		<detail><![CDATA[问“你的国家怎么走?” 他们都会指向诚实国]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[12个球一个天平，现知道只有一个和其它的重量不同，问怎样称才能用三次就找到那个球。13个呢？]]></question>
		<answer></answer>
		<detail><![CDATA[1，天平一边放四个，平则坏球在余下的四个里，好办。 不平，先将偏重的四个编号为：1、2、3、4。偏轻的编为A、B、C、D（因为不知道轻重）。
2。天平一边放三个，比如：左边放1、2、A。右边放3、4、B。 平则坏球是C、D 里偏轻的，不平则根据轻重淘汰1、2、B或 3、4、A]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[在一天的24小时之中，时钟的时针、分针和秒针完全重合在一起的时候有几次？都分别是什么时间？你怎样算出来的？]]></question>
		<answer></answer>
		<detail><![CDATA[11×2=22次
1时、13时的30/（6-0.5）=60/11=5又5/11分
2时、14时的60/（6-0.5)=120/11=10又10/11分
3时、15时的90/）6-0.5）=180/11=16又4/11分
4时、16时的120/（6-0.5)=240/11=21又9/11分
5时、17时的150/（6-0.5）=300/11=27又3/11分
6时、18时的180/（6-0.5)=360/11=32又8/11分
7时、19时的210/（6-0.5）=420/11=38又2/11分
8时、20时的240/（6-0.5）=480/11=43又7/11分
9时、21时的270/（6-0.5）=540/11=49又1/11分
10时、22时的300/（6-0.5）=600/11=54又6/11分
12时、24时整]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[五个海盗抢到了100颗宝石，每一颗都一样大小和价值连城。他们决定这么分： 抽签决定自己的号码（1、2、3、4、5） 首先，由1号提出分配方案，然后大家表决，当且仅当超过半数的人同意时，按照他的方案进行分配，否则将被扔进大海喂鲨鱼 如果1号死后，再由2号提出分配方案，然后剩下的4人进行表决，当且仅当超过半数的人同意时，按照他的方案进行分配，否则将被扔入大海喂鲨鱼 依此类推 条件：每个海盗都是很聪明的人，都能很理智地做出判断，从而做出选择。 问题：第一个海盗提出怎样的分配方案才能使自己的收益最大化？]]></question>
		<answer></answer>
		<detail><![CDATA[1号分配，依次是：97，0，1，0，2; 或者是：97，0，1，2，0，解答太长，详见：http://www.javamm.com/?p=7535]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[一道关于飞机加油的问题，已知： 每个飞机只有一个油箱， 飞机之间可以相互加油（注意是相互，没有加油机） 一箱油可供一架飞机绕地球飞半圈， 问题： 为使至少一架飞机绕地球一圈回到起飞时的飞机场，至少需要出动几架飞机？（所有飞机从同一机场起飞，而且必须安全返回机场，不允许中途降落，中间没有飞机场）]]></question>
		<answer></answer>
		<detail><![CDATA[共5架飞机 1，2，3，4，5
1，2，3号飞机从起点A起飞逆时针飞到全程8分之1加油点D，3号机为其他两架加满油返航。
1，2号继续飞到全程4分之1加油点B，2号机为1号机加满油返航。
1号飞机继续飞行到全程一半F点时，4号飞机从起点A起飞顺时针飞到加油点C，正好接到1号飞机，将自己油箱的油分给1号机一半后掉头与1号机一起往E点飞。
同时5号飞机在起点起飞顺时针飞到E点与1，4号会合将自己油箱剩的油平分，全部回到起点。图示讲解见：http://www.javamm.com/?p=7537]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[某手机厂家由于设计失误，有可能造成电池寿命比原来设计的寿命短一半（不是冲放电时间），解决方案就是免费更换电池或给50元购买该厂家新手机的折换券。请给所有已购买的用户写信告诉解决方案。]]></question>
		<answer></answer>
		<detail><![CDATA[亲爱的用户：您好，为了回报广大用户，我公司最近对N型电池进行了技术升级，凡在*年* 月*日前购买的N型电池用户，均可到我公司销售网点进行免费更换升 级。如果你更喜欢用原来的电池，我们将会送给你50元的新手机折换券。 再次感谢您对我们工作的支持！ **手机股份有限公司 *年*月*日（注意，不要搞用户已知道此电池设计寿命的假想，现在我们需要把实际的使用寿命当设计寿命，只不过价格相对低一点。我查看了一下我的手机说明 书，它并没有说明电池使用寿命，只说怎样使用寿命会长一些。所以可以回避寿命一事不谈。在答此问题时，应注意两个方面，一是不能让用户对公司失去信心，影 响声誉；二是要对用户负责，应值多少钱的东西就卖多少钱，所以，我就想了如上的表述方式，实际上，相对于原来的电池，现在也的确是一种技术升级，不存在欺 骗顾客）]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[一高层领导在参观某博物馆时，向博物馆馆员小王要了一块明代的城砖作为纪念，按国家规定，任何人不得将博物馆收藏品变为私有。博物馆馆长需要如何写信给这位领导，将城砖取回]]></question>
		<answer></answer>
		<detail><![CDATA[尊敬的**领导：您好！首先感谢您到我馆检查指导工作！按照你的指示，把相关的工作进行了完善，使我们的工作有了很大提高。在您走后，一位同志急着告诉 我，您带走了一块明代的城砖，问我怎么办，因为国家规定博物馆的收藏品不能变为私有，否则收藏者是违法的。我笑着告诉他，这是领导在考验我们，看我们的工 作是否严谨。我们真诚地感谢您为了考验我们的工作的良苦用心，同时，为了报答您对我们工作的指导，我们将于**月**日专门送一块该砖的仿制品作为纪念， 同时，取回我们的原砖。再次感谢你对我们工作的指导与关怀。 致 礼 ***博物馆馆长： *年*月*日（此题的关键我以为应激发领导的崇高心理。不知道大家是否记得周恩来总理用玩魔术的方法从外宾怀中取出被盗夜光杯的故事。所以，这里我用了相 似的办法。这里要注意两点，一是保住领导的面子，二是必须把砖拿回来，三是不能让领导认为现在博物馆的管理工作不到位，中间有这样一句话“问我怎么办，因 为国家规定博物馆的收藏品不能变为私有，否则收藏者是违法的。”，我们不是怕东西被拿走了，潜台词我们信任领导，而是怕领导违法，因为是为领导担心，一句 平实的话，分量很重，到这个份儿上，没有哪个领导再敢不还了。同时，送他一个仿制品，无论他是真想要，还是假想要，都应能给他的心灵以舒缓）。]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[营业员小姐由于工作失误，将2万元的笔记本电脑以1.2万元错卖给李先生，王小姐的经理怎么写信给李先生试图将钱要回来？]]></question>
		<answer></answer>
		<detail><![CDATA[尊敬的李先生：您好！首先感谢您使用我们公司的产品。您的支持是我们发展的动力。同时，我们还有一事希望与你协商。昨天在下班盘点时，营业员发现她在收款 时，因为看错了价格标签，错把2万元的电脑报价报成了1.2万元。按照公司的规定，如果不把此笔差额收回，她是要全额赔付的，这对于作营业员的小王来说， 相当于近一年的工资。当时她很着急，不愿说是怎么回事，几经询问，她才道出实情。她说她昨天在出售电脑给你时，和你谈得很投机，从你那里学到不少东西。因 为是自己工作的失误，她宁原自己赔付，也不愿意给你添麻烦。当时我告诉她，买这种产品的人都是高级知识分子或者素质很高的人，如果把事情说清楚，一定能把 钱收回来，我们不妨去试试，别人怎么能忍心让你赔呢？ 所以，我们给您写了这封信，希望得到你的支持，同时，也为我们工作的失误而给你带 来的不便深深致歉！再次感谢您对我们工作的支持，我们将静候回音。 致礼 **电脑营业部经理：** *年*月*日 (注意，在这封回信中，也充分地利用了激发他人崇高动机的手法，同时运用了同理心等。这封信中有一点假设，就是小王和他聊得很投机，以致不愿意要回电脑， 是否愿意自己赔这个细节可以省略，但聊得很投机，学到了知识，最好提到。因为这是极为可能的，电脑的价格高，属于理性消费品，它一般来说，讨价还价不同于 感性的日常消费品，消费者可能会经过比较久的选择时间，这样，会增加用户对小王的好感，增大还款的胜算。)
顺便插一个小案例，一次某子公司的出纳员也是把钱给一原料客户取多了，后来，也用类似的办法取回来，主要用了激发用户的崇高动机手法。后来用户给钱时说， 这钱不是我欠你的，因为没有任何证据可以证明我欠你的钱，这与本例有不同之处，本例有发票证明是少开了。找到用户时，我们也告诉他，你可以不还，如果不 还，这个出纳员需要全部赔偿，至少是她一年的工资。但我们相信你会同情这个出纳员，你作为一个大老板，一定非常讲商誉才能发展到今天，你帮助了很多的人致 富，相信你也会帮助她一把。后来，他说，好吧，此款我作为赠送，因为我们的合作愉快，我把它赠送给你们的出纳员（而不是还），就这样，把钱要了回来。) ]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[String是最基本的数据类型吗?]]></question>
		<answer>2,</answer>
		<detail><![CDATA[基本数据类型包括byte、int、char、long、float、double、boolean和short。java.lang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间，我们应该用StringBuffer类]]></detail>
		<options>
			<option><![CDATA[是]]></option>
			<option><![CDATA[不是]]></option>
		</options>
	</exam>
	<exam>
		<question><![CDATA[int 和 Integer 有什么区别]]></question>
		<answer></answer>
		<detail><![CDATA[Java 提供两种不同的类型：引用类型和原始类型（或内置类型）。Int是java的原始数据类型，Integer是java为int提供的封装类。Java为每个原始类型提供了封装类。
原始类型封装类
boolean Boolean
char Character
byte Byte
short Short
int Integer
long Long
float Float
double Double]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[String 和StringBuffer的区别]]></question>
		<answer></answer>
		<detail><![CDATA[JAVA平台提供了两个类：String和StringBuffer，它们可以储存和操作字符串，即包含多个字符的字符数据。这个String类提供了数值不可改变的字符串。而这个StringBuffer类提供的字符串进行修改。当你知道字符数据要改变的时候你就可以使用StringBuffer。典型地，你可以使用StringBuffers来动态构造字符数据。]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[说出Servlet的生命周期，并说出Servlet和CGI的区别。]]></question>
		<answer></answer>
		<detail><![CDATA[Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法自动派遣运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用其destroy方法。
与cgi的区别在于servlet处于服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于servlet。]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[说出ArrayList,Vector, LinkedList的存储性能和特性]]></question>
		<answer></answer>
		<detail><![CDATA[ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差，而LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[EJB是基于哪些技术实现的？并说出SessionBean和EntityBean的区别，StatefulBean和StatelessBean的区别。]]></question>
		<answer></answer>
		<detail><![CDATA[EJB包括Session Bean、Entity Bean、Message Driven Bean，基于JNDI、RMI、JAT等技术实现。
SessionBean在J2EE应用程序中被用来完成一些服务器端的业务操作，例如访问数据库、调用其他EJB组件。EntityBean被用来代表应用系统中用到的数据。
对于客户机，SessionBean是一种非持久性对象，它实现某些在服务器上运行的业务逻辑。
对于客户机，EntityBean是一种持久性对象，它代表一个存储在持久性存储器中的实体的对象视图，或是一个由现有企业应用程序实现的实体。
Session Bean 还可以再细分为 Stateful Session Bean 与 Stateless Session Bean ，这两种的 Session Bean都可以将系统逻辑放在 method之中执行，不同的是 Stateful Session Bean 可以记录呼叫者的状态，因此通常来说，一个使用者会有一个相对应的 Stateful Session Bean 的实体。Stateless Session Bean 虽然也是逻辑组件，但是他却不负责记录使用者状态，也就是说当使用者呼叫 Stateless Session Bean 的时候，EJB Container 并不会找寻特定的 Stateless Session Bean 的实体来执行这个 method。换言之，很可能数个使用者在执行某个 Stateless Session Bean 的 methods 时，会是同一个 Bean 的 Instance 在执行。从内存方面来看， Stateful Session Bean 与 Stateless Session Bean 比较， Stateful Session Bean 会消耗 J2EE Server 较多的内存，然而 Stateful Session Bean 的优势却在于他可以维持使用者的状态。]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[Collection 和 Collections的区别]]></question>
		<answer></answer>
		<detail><![CDATA[Collection是集合类的上级接口，继承与他的接口主要有Set 和List.
Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[HashMap和Hashtable的区别]]></question>
		<answer></answer>
		<detail><![CDATA[HashMap是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口，主要区别在于HashMap允许空（null）键值（key）,由于非线程安全，效率上可能高于Hashtable。
HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。
HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey。因为contains方法容易让人引起误解。 
Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现。
最大的不同是，Hashtable的方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。 
Hashtable和HashMap采用的hash/rehash算法都大概一样，所以性能不会有很大的差异。]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[final, finally, finalize的区别]]></question>
		<answer></answer>
		<detail><![CDATA[final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。
finally是异常处理语句结构的一部分，表示总是执行。
finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[sleep() 和 wait() 有什么区别?]]></question>
		<answer></answer>
		<detail><![CDATA[sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。
wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型?]]></question>
		<answer></answer>
		<detail><![CDATA[方法的重写Overriding和重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded的方法是可以改变返回值的类型。]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[error和exception有什么区别?]]></question>
		<answer></answer>
		<detail><![CDATA[error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。
exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[abstract class和interface有什么区别?]]></question>
		<answer></answer>
		<detail><![CDATA[声明方法的存在而不去实现它的类被叫做抽象类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建abstract 类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。Abstract 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法。
接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽象的，没有一个有程序体。接口只可以定义static final成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。然后，它可以在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到接口类型或从接口类型转换，instanceof 运算符可以用来决定某对象的类是否实现了接口。]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[heap和stack有什么区别。]]></question>
		<answer></answer>
		<detail><![CDATA[栈是一种线形集合，其添加和删除元素的操作应在同一段完成。栈按照后进先出的方式进行处理。
堆是栈的一个组成元素]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[Static Nested Class 和 Inner Class的不同。 ]]></question>
		<answer></answer>
		<detail><![CDATA[Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化。]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[JSP中动态INCLUDE与静态INCLUDE的区别？]]></question>
		<answer></answer>
		<detail><![CDATA[动态INCLUDE用jsp:include动作实现 <jsp:include page="included.jsp" flush="true" />它总是会检查所含文件中的变化，适合用于包含动态页面，并且可以带参数。
静态INCLUDE用include伪码实现,定不会检查所含文件的变化，适用于包含静态页面<%@ include file="included.htm" %> ]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[什么时候用assert]]></question>
		<answer></answer>
		<detail><![CDATA[assertion(断言)在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。在实现中，assertion就是在程序中的一条语句，它对一个boolean表达式进行检查，一个正确程序必须保证这个boolean表达式的值为true；如果该值为false，说明程序已经处于不正确的状态下，系统将给出警告或退出。一般来说，assertion用于保证程序最基本、关键的正确性。assertion检查通常在开发和测试时开启。为了提高性能，在软件发布后，assertion检查通常是关闭的。]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[GC是什么? 为什么要有GC? ]]></question>
		<answer></answer>
		<detail><![CDATA[GC是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。 ]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错? ]]></question>
		<answer></answer>
		<detail><![CDATA[short s1 = 1; s1 = s1 + 1; （s1+1运算结果是int型，需要强制转换类型）
short s1 = 1; s1 += 1;（可以正确编译）]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[Math.round(11.5)等於多少? Math.round(-11.5)等於多少?]]></question>
		<answer></answer>
		<detail><![CDATA[Math.round(11.5)==12
Math.round(-11.5)==-11
round方法返回与参数最接近的长整数，参数加1/2后求其floor.]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[String s = new String("xyz");创建了几个String Object?]]></question>
		<answer></answer>
		<detail><![CDATA[两个]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[Java有没有goto?]]></question>
		<answer></answer>
		<detail><![CDATA[java中的保留字，现在没有在java中使用。]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[启动一个线程是用run()还是start()?]]></question>
		<answer></answer>
		<detail><![CDATA[启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM调度并执行。这并不意味着线程就会立即运行。run()方法可以产生必须退出的标志来停止一个线程。]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[EJB包括（SessionBean,EntityBean）说出他们的生命周期，及如何管理事务的？]]></question>
		<answer></answer>
		<detail><![CDATA[SessionBean：Stateless Session Bean 的生命周期是由容器决定的，当客户机发出请求要建立一个Bean的实例时，EJB容器不一定要创建一个新的Bean的实例供客户机调用，而是随便找一个现有的实例提供给客户机。当客户机第一次调用一个Stateful Session Bean 时，容器必须立即在服务器中创建一个新的Bean实例，并关联到客户机上，以后此客户机调用Stateful Session Bean 的方法时容器会把调用分派到与此客户机相关联的Bean实例。
EntityBean：Entity Beans能存活相对较长的时间，并且状态是持续的。只要数据库中的数据存在，Entity beans就一直存活。而不是按照应用程序或者服务进程来说的。即使EJB容器崩溃了，Entity beans也是存活的。Entity Beans生命周期能够被容器或者 Beans自己管理。
EJB通过以下技术管理实务：对象管理组织（OMG）的对象实务服务（OTS），Sun Microsystems的Transaction Service（JTS）、Java Transaction API（JTA），开发组（X/Open）的XA接口。]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[应用服务器有那些？]]></question>
		<answer></answer>
		<detail><![CDATA[BEA WebLogic Server，IBM WebSphere Application Server，Oracle9i Application Server，jBoss，Tomcat]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[给我一个你最常见到的runtime exception]]></question>
		<answer></answer>
		<detail><![CDATA[ArithmeticException, ArrayStoreException, BufferOverflowException, BufferUnderflowException, CannotRedoException, CannotUndoException, ClassCastException, CMMException, ConcurrentModificationException, DOMException, EmptyStackException, IllegalArgumentException, IllegalMonitorStateException, IllegalPathStateException, IllegalStateException, ImagingOpException, IndexOutOfBoundsException, MissingResourceException, NegativeArraySizeException, NoSuchElementException, NullPointerException, ProfileDataException, ProviderException, RasterFormatException, SecurityException, SystemException, UndeclaredThrowableException, UnmodifiableSetException, UnsupportedOperationException]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承实体类(concrete class)?]]></question>
		<answer></answer>
		<detail><![CDATA[接口可以继承接口。抽象类可以实现(implements)接口，抽象类是否可继承实体类，但前提是实体类必须有明确的构造函数]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[List, Set, Map是否继承自Collection接口?]]></question>
		<answer></answer>
		<detail><![CDATA[List，Set是，Map不是]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[说出数据连接池的工作机制是什么?]]></question>
		<answer></answer>
		<detail><![CDATA[J2EE服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接。客户端程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙。如果当前没有空闲连接，池驱动程序就新建一定数量的连接，新建连接的数量有配置参数决定。当使用的池连接调用完成后，池驱动程序将此连接表记为空闲，其他调用就可以使用这个连接]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[abstract的method是否可同时是static,是否可同时是native，是否可同时是synchronized?]]></question>
		<answer></answer>
		<detail><![CDATA[都不能]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[数组有没有length()这个方法? String有没有length()这个方法？]]></question>
		<answer></answer>
		<detail><![CDATA[数组没有length()这个方法，有length的属性。String有有length()这个方法]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是equals()? 它们有何区别?]]></question>
		<answer></answer>
		<detail><![CDATA[Set里的元素是不能重复的，那么用iterator()方法来区分重复与否。equals()是判读两个Set是否相等。
equals()和==方法决定引用值是否指向同一对象equals()在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[构造器Constructor是否可被override?]]></question>
		<answer></answer>
		<detail><![CDATA[构造器Constructor不能被继承，因此不能重写Overriding，但可以被重载Overloading]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[是否可以继承String类?]]></question>
		<answer></answer>
		<detail><![CDATA[String类是final类故不可以继承]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上?]]></question>
		<answer></answer>
		<detail><![CDATA[switch（expr1）中，expr1是一个整数表达式。因此传递给 switch 和 case 语句的参数应该是 int、 short、 char 或者 byte。long,string 都不能作用于swtich。]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[try {}里有一个return语句，那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后?]]></question>
		<answer></answer>
		<detail><![CDATA[会执行，在return前执行]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[编程题: 用最有效率的方法算出2乘以8等於几? ]]></question>
		<answer></answer>
		<detail><![CDATA[2 << 3]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，对不对?]]></question>
		<answer>2,</answer>
		<detail><![CDATA[不对，有相同的hash code]]></detail>
		<options>
			<option><![CDATA[对]]></option>
			<option><![CDATA[不对]]></option>
		</options>
	</exam>
	<exam>
		<question><![CDATA[当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?]]></question>
		<answer></answer>
		<detail><![CDATA[不能，一个对象的一个synchronized方法只能由一个线程访问]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[写一个Singleton出来]]></question>
		<answer></answer>
		<detail><![CDATA[第一种形式: 定义一个类，它的构造函数为private的，它有一个static的private的该类变量，在类初始化时实例话，通过一个public的getInstance方法获取对它的引用,继而调用其中的方法。
public class Singleton {
private Singleton(){}
　　 //在自己内部定义自己一个实例，是不是很奇怪？
　　 //注意这是private 只供内部调用
　　 private static Singleton instance = new Singleton();
　　 //这里提供了一个供外部访问本class的静态方法，可以直接访问　　
　　 public static Singleton getInstance() {
　　　　 return instance; 　　
　　 } 
} 
第二种形式: 
public class Singleton { 
　　private static Singleton instance = null;
　　public static synchronized Singleton getInstance() {
　　//这个方法比上面有所改进，不用每次都进行生成对象，只是第一次　　　 　
　　//使用时生成实例，提高了效率！
　　if (instance==null)
　　　　instance＝new Singleton();
return instance; 　　} 
} 
其他形式:
定义一个类，它的构造函数为private的，所有方法为static的]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[Java的接口和C++的虚类的相同和不同处。]]></question>
		<answer></answer>
		<detail><![CDATA[由于Java不支持多继承，而有可能某个类或对象要使用分别在几个类或对象里面的方法或属性，现有的单继承机制就不能满足要求。与继承相比，接口有更高的灵活性，因为接口中没有任何实现代码。当一个类实现了接口以后，该类要实现接口里面所有的方法和属性，并且接口里面的属性在默认状态下面都是public static,所有方法默认情况下是public.一个类可以实现多个接口]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[Java中的异常处理机制的简单原理和应用]]></question>
		<answer></answer>
		<detail><![CDATA[当JAVA程序违反了JAVA的语义规则时，JAVA虚拟机就会将发生的错误表示为一个异常。违反语义规则包括2种情况。一种是JAVA类库内置的语义检查。例如数组下标越界,会引发IndexOutOfBoundsException;访问null的对象时会引发NullPointerException。另一种情况就是JAVA允许程序员扩展这种语义检查，程序员可以创建自己的异常，并自由选择在何时用throw关键字引发异常。所有的异常都是java.lang.Thowable的子类]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[垃圾回收的优点和原理。并考虑2种回收机制]]></question>
		<answer></answer>
		<detail><![CDATA[Java语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存管理的问题迎刃而解，它使得Java程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java中的对象不再有“作用域”的概念，只有对象的引用才有“作用域”。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清楚和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[你所知道的集合类都有哪些？主要方法？]]></question>
		<answer></answer>
		<detail><![CDATA[最常用的集合类是 List 和 Map。 List 的具体实现包括 ArrayList 和 Vector，它们是可变大小的列表，比较适合构建、存储和操作任何类型对象的元素列表。 List 适用于按数值索引访问元素的情形。 
Map 提供了一个更通用的元素存储方法。 Map 集合类用于存储元素对（称作“键”和“值”），其中每个键映射到一个值]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[描述一下JVM加载class文件的原理机制?]]></question>
		<answer></answer>
		<detail><![CDATA[JVM中类的装载是由ClassLoader和它的子类来实现的,Java ClassLoader 是一个重要的Java运行时系统组件。它负责在运行时查找和装入类文件的类]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[线程的基本概念、线程的基本状态以及状态之间的关系]]></question>
		<answer></answer>
		<detail><![CDATA[线程指在程序执行过程中，能够执行程序代码的一个执行单位，每个程序至少都有一个线程，也就是程序本身。
Java中的线程有四种状态分别是：运行、就绪、挂起、结束]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[什么情况下调用doGet()和doPost()？]]></question>
		<answer></answer>
		<detail><![CDATA[Jsp页面中的form标签里的method属性为get时调用doGet()，为post时调用doPost()。]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[如何现实servlet的单线程模式]]></question>
		<answer></answer>
		<detail><![CDATA[<%@ page isThreadSafe=”false”%>]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[页面间对象传递的方法]]></question>
		<answer></answer>
		<detail><![CDATA[request，session，application，cookie等]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[JSP和Servlet有哪些相同点和不同点，他们之间的联系是什么？]]></question>
		<answer></answer>
		<detail><![CDATA[JSP是Servlet技术的扩展，本质上是Servlet的简易方式，更强调应用的外表表达。JSP编译后是"类servlet"。Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML里分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。JSP侧重于视图，Servlet主要用于控制逻辑]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[2EE是技术还是平台还是框架？]]></question>
		<answer></answer>
		<detail><![CDATA[J2EE本身是一个标准，一个为企业分布式应用的开发提供的标准平台。
J2EE也是一个框架，包括JDBC、JNDI、RMI、JMS、EJB、JTA等技术]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种编码的字符串]]></question>
		<answer></answer>
		<detail><![CDATA[Public String translate (String str) {
String tempStr = "";
try {
tempStr = new String(str.getBytes("ISO-8859-1"), "GBK");
tempStr = tempStr.trim();
}
catch (Exception e) {
System.err.println(e.getMessage());
}
return tempStr;
}]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[简述逻辑操作(&,|,^)与条件操作(&&,||)的区别]]></question>
		<answer></answer>
		<detail><![CDATA[区别主要答两点：a.条件操作只能操作布尔型的,而逻辑操作不仅可以操作布尔型,而且可以操作数值型
b.逻辑操作不会产生短路]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？ ]]></question>
		<answer></answer>
		<detail><![CDATA[a: 两种形式 dtd schema，b: 本质区别:schema本身是xml的，可以被XML解析器解析(这也是从DTD上发展schema的根本目的)，c:有DOM,SAX,STAX等 
DOM:处理大型文件时其性能下降的非常厉害。这个问题是由DOM的树结构所造成的，这种结构占用的内存较多，而且DOM必须在解析文件之前把整个文档装入内存,适合对XML的随机访问
SAX:不现于DOM,SAX是事件驱动型的XML解析方式。它顺序读取XML文件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过在其回调事件中写入处理代码来处理XML文件，适合对XML的顺序访问 
STAX:Streaming API for XML (StAX)]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[简述synchronized和java.util.concurrent.locks.Lock的异同 ？]]></question>
		<answer></answer>
		<detail><![CDATA[主要相同点：Lock能完成synchronized所实现的所有功能
主要不同点：Lock有比synchronized更精确的线程语义和更好的性能。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[如何给weblogic指定大小的内存?]]></question>
		<answer></answer>
		<detail><![CDATA[在启动Weblogic的脚本中（位于所在Domian对应服务器目录下的startServerName），增加set MEM_ARGS=-Xms32m -Xmx200m，可以调整最小内存为32M，最大200M]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[说说你所熟悉或听说过的j2ee中的几种常用模式?及对设计模式的一些看法]]></question>
		<answer></answer>
		<detail><![CDATA[Session Facade Pattern：使用SessionBean访问EntityBean
Message Facade Pattern：实现异步调用
EJB Command Pattern：使用Command JavaBeans取代SessionBean，实现轻量级访问
Data Transfer Object Factory：通过DTO Factory简化EntityBean数据提供特性
Generic Attribute Access：通过AttibuteAccess接口简化EntityBean数据提供特性
Business Interface：通过远程（本地）接口和Bean类实现相同接口规范业务逻辑一致性]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[排序都有哪几种方法？请列举。用JAVA实现一个快速排序]]></question>
		<answer></answer>
		<detail><![CDATA[排序的方法有：插入排序（直接插入排序、希尔排序），交换排序（冒泡排序、快速排序），选择排序（直接选择排序、堆排序），归并排序，分配排序（箱排序、基数排序）
快速排序的伪代码。
/ /使用快速排序方法对a[ 0 :n- 1 ]排序
从a[ 0 :n- 1 ]中选择一个元素作为m i d d l e，该元素为支点
把余下的元素分割为两段left 和r i g h t，使得l e f t中的元素都小于等于支点，而right 中的元素都大于等于支点
递归地使用快速排序方法对left 进行排序
递归地使用快速排序方法对right 进行排序
所得结果为l e f t + m i d d l e + r i g h t]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[请对以下在J2EE中常用的名词进行解释(或简单描述):web容器,EJB容器,JNDI,JMS,JTA,JAF,RMI/IIO]]></question>
		<answer></answer>
		<detail><![CDATA[web容器：给处于其中的应用程序组件（JSP，SERVLET）提供一个环境，使JSP,SERVLET直接更容器中的环境变量接口交互，不必关注其它系统问题。主要有WEB服务器来实现。例如：TOMCAT,WEBLOGIC,WEBSPHERE等。该容器提供的接口严格遵守J2EE规范中的WEB APPLICATION 标准。我们把遵守以上标准的WEB服务器就叫做J2EE中的WEB容器。
EJB容器：Enterprise java bean 容器。更具有行业领域特色。他提供给运行在其中的组件EJB各种管理功能。只要满足J2EE规范的EJB放入该容器，马上就会被容器进行高效率的管理。并且可以通过现成的接口来获得系统级别的服务。例如邮件服务、事务管理。
JNDI：（Java Naming & Directory Interface）JAVA命名目录服务。主要提供的功能是：提供一个目录系统，让其它各地的应用程序在其上面留下自己的索引，从而满足快速查找和定位分布式应用程序的功能。
JMS：（Java Message Service）JAVA消息服务。主要实现各个应用程序之间的通讯。包括点对点和广播。
JTA：（Java Transaction API）JAVA事务服务。提供各种分布式事务服务。应用程序只需调用其提供的接口即可。
JAF：（Java Action FrameWork）JAVA安全认证框架。提供一些安全控制方面的框架。让开发者通过各种部署和自定义实现自己的个性安全控制策略。
RMI/IIOP:（Remote Method Invocation /internet对象请求中介协议）他们主要用于通过远程调用服务。例如，远程有一台计算机上运行一个程序，它提供股票分析服务，我们可以在本地计算机上实现对其直接调用。当然这是要通过一定的规范才能在异构的系统之间进行通信。RMI是JAVA特有的]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[一个“.java”源文件中是否可以包括多个类（不是内部类）？有什么限制]]></question>
		<answer></answer>
		<detail><![CDATA[可以。必须只有一个类名与文件名相同]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[MVC的各个部分都有那些技术来实现?如何实现?]]></question>
		<answer></answer>
		<detail><![CDATA[MVC是Model－View－Controller的简写。"Model" 代表的是应用的业务逻辑（通过JavaBean，EJB组件实现）， "View" 是应用的表示面（由JSP页面产生），"Controller" 是提供应用的处理过程控制（一般是一个Servlet），通过这种设计模型把应用逻辑，处理过程和显示逻辑分成不同的组件实现。这些组件可以进行交互和重用]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[java中有几种方法可以实现一个线程？用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用？]]></question>
		<answer></answer>
		<detail><![CDATA[有两种实现方法，分别是继承Thread类与实现Runnable接口
用synchronized关键字修饰同步方法
反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被“挂起”的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用suspend()，而应在自己的Thread类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用wait()命其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？]]></question>
		<answer></answer>
		<detail><![CDATA[字节流，字符流。字节流继承于InputStream OutputStream，字符流继承于InputStreamReader OutputStreamWriter。在java.io包中还有许多其他的流，主要是为了提高性能和使用方便]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[java中会存在内存泄漏吗，请简单描述]]></question>
		<answer></answer>
		<detail><![CDATA[会。如：int i,i2; return (i-i2); //when i为足够大的正数,i2为足够大的负数。结果会造成溢位，导致错误]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？]]></question>
		<answer></answer>
		<detail><![CDATA[对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是"可达的"，哪些对象是"不可达的"。当GC确定一些对象为"不可达"时，GC就有责任回收这些内存空间。可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[静态变量和实例变量的区别？]]></question>
		<answer></answer>
		<detail><![CDATA[static i = 10; //常量
class A a; a.i =10;//可变]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[什么是java序列化，如何实现java序列化？]]></question>
		<answer></answer>
		<detail><![CDATA[序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题。
序列化的实现：将需要被序列化的类实现Serializable接口，该接口没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化的，然后使用一个输出流(如：FileOutputStream)来构造一个ObjectOutputStream(对象流)对象，接着，使用ObjectOutputStream对象的writeObject(Object obj)方法就可以将参数为obj的对象写出(即保存其状态)，要恢复的话则用输入流]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[是否可以从一个static方法内部发出对非static方法的调用？]]></question>
		<answer></answer>
		<detail><![CDATA[不可以,如果其中包含对象的method()；不能保证对象初始化]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[写clone()方法时，通常都有一行代码，是什么？]]></question>
		<answer></answer>
		<detail><![CDATA[Clone 有缺省行为，super.clone();他负责产生正确大小的空间，并逐位复制]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[在JAVA中，如何跳出当前的多重嵌套循环？]]></question>
		<answer></answer>
		<detail><![CDATA[用break; return 方法]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[List、Map、Set三个接口，存取元素时，各有什么特点？]]></question>
		<answer></answer>
		<detail><![CDATA[List 以特定次序来持有元素，可有重复元素。Set 无法拥有重复元素,内部排序。Map 保存key-value值，value可多值]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[说出一些常用的类，包，接口，请各举5个]]></question>
		<answer></answer>
		<detail><![CDATA[常用的类：BufferedReader BufferedWriter FileReader FileWirter String Integer
常用的包：java.lang java.awt java.io java.util java.sql
常用的接口：Remote List Map Document NodeList ]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[Anonymous Inner Class (匿名内部类) 是否可以extends(继承)其它类，是否可以implements(实现)interface(接口)?]]></question>
		<answer></answer>
		<detail><![CDATA[可以继承其他类或完成其他接口，在swing编程中常用此方式]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[应用服务器与WEB SERVER的区别？]]></question>
		<answer></answer>
		<detail><![CDATA[应用服务器：Weblogic、Tomcat、Jboss
WEB SERVER：IIS、 Apache]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[JAVA代码查错
1.
abstract class Name {
private String name;
public abstract boolean isStupidName(String name) {}
}
这有何错误?]]></question>
		<answer></answer>
		<detail><![CDATA[错。abstract method必须以分号结尾，且不带花括号]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[public class Something {
void doSomething () {
private String s = "";
int l = s.length();
}
}
有错吗?]]></question>
		<answer></answer>
		<detail><![CDATA[错。局部变量前不能放置任何访问修饰符 (private，public，和protected)。final可以用来修饰局部变量
(final如同abstract和strictfp，都是非访问修饰符，strictfp只能修饰class和method而非variable)。]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[abstract class Something {
private abstract String doSomething ();
}
有什么错吗 ?]]></question>
		<answer></answer>
		<detail><![CDATA[错。abstract的methods不能以private修饰。abstract的methods就是让子类implement(实现)具体细节的，怎么可以用private把abstract
method封锁起来呢? (同理，abstract method前不能加final)]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[以下代码有什么错误
public class Something {
public int addOne(final int x) {
return ++x;
}
}]]></question>
		<answer></answer>
		<detail><![CDATA[int x被修饰成final，意味着x不能在addOne method中被修改]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[现在输入n个数字，以逗号，分开；然后可选择升或者降序排序；按提交键就在另一页面显示按什么排序，结果为，提供reset]]></question>
		<answer></answer>
		<detail><![CDATA[import java.util.*;
public class bycomma{
public static String[] splitStringByComma(String source){
if(source==null||source.trim().equals(""))
return null;
StringTokenizer commaToker = new StringTokenizer(source,",");
String[] result = new String[commaToker.countTokens()];
int i=0;
while(commaToker.hasMoreTokens()){
result[i] = commaToker.nextToken();
i++;
}
return result;
}
public static void main(String args[]){
String[] s = splitStringByComma("5,8,7,4,3,9,1");
int[] ii = new int[s.length];
for(int i = 0;i<s.length;i++){
ii[i] =Integer.parseInt(s[i]);
}
Arrays.sort(ii);
//asc
for(int i=0;i<s.length;i++){
System.out.println(ii[i]);
}
//desc
for(int i=(s.length-1);i>=0;i--){
System.out.println(ii[i]);
}
}
}]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[金额转换，阿拉伯数字的金额转换成中国传统的形式如：（￥1011）－>（一千零一拾一元整）输出。]]></question>
		<answer></answer>
		<detail><![CDATA[package com.javamm;
import java.text.NumberFormat;
import java.util.HashMap;
public class SimpleMoneyFormat {
public static final String EMPTY = "";
public static final String ZERO = "零";
public static final String ONE = "壹";
public static final String TWO = "贰";
public static final String THREE = "叁";
public static final String FOUR = "肆";
public static final String FIVE = "伍";
public static final String SIX = "陆";
public static final String SEVEN = "柒";
public static final String EIGHT = "捌";
public static final String NINE = "玖";
public static final String TEN = "拾";
public static final String HUNDRED = "佰";
public static final String THOUSAND = "仟";
public static final String TEN_THOUSAND = "万";
public static final String HUNDRED_MILLION = "亿";
public static final String YUAN = "元";
public static final String JIAO = "角";
public static final String FEN = "分";
public static final String DOT = ".";

private static SimpleMoneyFormat formatter = null;
private HashMap chineseNumberMap = new HashMap();
private HashMap chineseMoneyPattern = new HashMap();
private NumberFormat numberFormat = NumberFormat.getInstance();

private SimpleMoneyFormat() {
numberFormat.setMaximumFractionDigits(4);
numberFormat.setMinimumFractionDigits(2);
numberFormat.setGroupingUsed(false);

chineseNumberMap.put("0", ZERO);
chineseNumberMap.put("1", ONE);
chineseNumberMap.put("2", TWO);
chineseNumberMap.put("3", THREE);
chineseNumberMap.put("4", FOUR);
chineseNumberMap.put("5", FIVE);
chineseNumberMap.put("6", SIX);
chineseNumberMap.put("7", SEVEN);
chineseNumberMap.put("8", EIGHT);
chineseNumberMap.put("9", NINE);
chineseNumberMap.put(DOT, DOT);

chineseMoneyPattern.put("1", TEN);
chineseMoneyPattern.put("2", HUNDRED);
chineseMoneyPattern.put("3", THOUSAND);
chineseMoneyPattern.put("4", TEN_THOUSAND);
chineseMoneyPattern.put("5", TEN);
chineseMoneyPattern.put("6", HUNDRED);
chineseMoneyPattern.put("7", THOUSAND);
chineseMoneyPattern.put("8", HUNDRED_MILLION);
}

public static SimpleMoneyFormat getInstance() {
if (formatter == null)
formatter = new SimpleMoneyFormat();
return formatter;
}

public String format(String moneyStr) {
checkPrecision(moneyStr);
String result;
result = convertToChineseNumber(moneyStr);
result = addUnitsToChineseMoneyString(result);
return result;
}

public String format(double moneyDouble) {
return format(numberFormat.format(moneyDouble));
}

public String format(int moneyInt) {
return format(numberFormat.format(moneyInt));
}

public String format(long moneyLong) {
return format(numberFormat.format(moneyLong));
}

public String format(Number moneyNum) {
return format(numberFormat.format(moneyNum));
}

private String convertToChineseNumber(String moneyStr) {
String result;
StringBuffer cMoneyStringBuffer = new StringBuffer();
for (int i = 0; i < moneyStr.length(); i++) {
cMoneyStringBuffer.append(chineseNumberMap.get(moneyStr.substring(i, i + 1)));
}
//拾佰仟万亿等都是汉字里面才有的单位，加上它们
int indexOfDot = cMoneyStringBuffer.indexOf(DOT);
int moneyPatternCursor = 1;
for (int i = indexOfDot - 1; i > 0; i--) {
cMoneyStringBuffer.insert(i, chineseMoneyPattern.get(EMPTY + moneyPatternCursor));
moneyPatternCursor = moneyPatternCursor == 8 ? 1 : moneyPatternCursor + 1;
}

String fractionPart = cMoneyStringBuffer.substring(cMoneyStringBuffer.indexOf("."));
cMoneyStringBuffer.delete(cMoneyStringBuffer.indexOf("."), cMoneyStringBuffer.length());
while (cMoneyStringBuffer.indexOf("零拾") != -1) {
cMoneyStringBuffer.replace(cMoneyStringBuffer.indexOf("零拾"), cMoneyStringBuffer.indexOf("零拾") + 2, ZERO);
}
while (cMoneyStringBuffer.indexOf("零佰") != -1) {
cMoneyStringBuffer.replace(cMoneyStringBuffer.indexOf("零佰"), cMoneyStringBuffer.indexOf("零佰") + 2, ZERO);
}
while (cMoneyStringBuffer.indexOf("零仟") != -1) {
cMoneyStringBuffer.replace(cMoneyStringBuffer.indexOf("零仟"), cMoneyStringBuffer.indexOf("零仟") + 2, ZERO);
}
while (cMoneyStringBuffer.indexOf("零万") != -1) {
cMoneyStringBuffer.replace(cMoneyStringBuffer.indexOf("零万"), cMoneyStringBuffer.indexOf("零万") + 2, TEN_THOUSAND);
}
while (cMoneyStringBuffer.indexOf("零亿") != -1) {
cMoneyStringBuffer.replace(cMoneyStringBuffer.indexOf("零亿"), cMoneyStringBuffer.indexOf("零亿") + 2, HUNDRED_MILLION);
}
while (cMoneyStringBuffer.indexOf("零零") != -1) {
cMoneyStringBuffer.replace(cMoneyStringBuffer.indexOf("零零"), cMoneyStringBuffer.indexOf("零零") + 2, ZERO);
}
if (cMoneyStringBuffer.lastIndexOf(ZERO) == cMoneyStringBuffer.length() - 1)
cMoneyStringBuffer.delete(cMoneyStringBuffer.length() - 1, cMoneyStringBuffer.length());
cMoneyStringBuffer.append(fractionPart);

result = cMoneyStringBuffer.toString();
return result;
}


private String addUnitsToChineseMoneyString(String moneyStr) {
String result;
StringBuffer cMoneyStringBuffer = new StringBuffer(moneyStr);
int indexOfDot = cMoneyStringBuffer.indexOf(DOT);
cMoneyStringBuffer.replace(indexOfDot, indexOfDot + 1, YUAN);
cMoneyStringBuffer.insert(cMoneyStringBuffer.length() - 1, JIAO);
cMoneyStringBuffer.insert(cMoneyStringBuffer.length(), FEN);
if (cMoneyStringBuffer.indexOf("零角零分") != -1)//没有零头，加整
cMoneyStringBuffer.replace(cMoneyStringBuffer.indexOf("零角零分"), cMoneyStringBuffer.length(), "整");
else
if (cMoneyStringBuffer.indexOf("零分") != -1)//没有零分，加整
cMoneyStringBuffer.replace(cMoneyStringBuffer.indexOf("零分"), cMoneyStringBuffer.length(), "整");
else {
if(cMoneyStringBuffer.indexOf("零角")!=-1)
cMoneyStringBuffer.delete(cMoneyStringBuffer.indexOf("零角"),cMoneyStringBuffer.indexOf("零角")+2);
// tmpBuffer.append("整");
}
result = cMoneyStringBuffer.toString();
return result;
}

private void checkPrecision(String moneyStr) {
int fractionDigits = moneyStr.length() - moneyStr.indexOf(DOT) - 1;
if (fractionDigits > 2)
throw new RuntimeException("金额" + moneyStr + "的小数位多于两位。"); //精度不能比分低
}

public static void main(String args[]) {
System.out.println(getInstance().format(new Double(10010001.01)));
}
}]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[能不能自己写个类，也叫java.lang.String？]]></question>
		<answer></answer>
		<detail><![CDATA[可以，但在应用的时候，需要用自己的类加载器去加载，否则，系统的类加载器永远只是去加载jre.jar包中的那个 java.lang.String。由于在tomcat的web应用程序中，都是由webapp自己的类加载器先自己加载WEB- INF/classess目录中的类，然后才委托上级的类加载器加载，如果我们在tomcat的web应用程序中写一个 java.lang.String，这时候Servlet程序加载的就是我们自己写的java.lang.String，但是这么干就会出很多潜在的问题，原来所有用了java.lang.String类的都将出现问题。
虽然java提供了endorsed技术，可以覆盖jdk中的某些类，具体做法是….。但是，能够被覆盖的类是有限制范围，反正不包括java.lang这样的包中的类。]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[考虑一个双人游戏。游戏在一个圆桌上进行。每个游戏者都有足够多的硬币。他们需要在桌子上轮流放置硬币，每次必需且只能放置一枚硬币，要求硬币完全置于桌面内（不能有一部分悬在桌子外面），并且不能与原来放过的硬币重叠。谁没有地方放置新的硬币，谁就输了。游戏的先行者还是后行者有必胜策略？这种策略是什么？]]></question>
		<answer></answer>
		<detail><![CDATA[先行者在桌子中心放置一枚硬币，以后的硬币总是放在与后行者刚才放的地方相对称的位置。这样，只要后行者能放，先行者一定也有地方放。先行者必胜]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question><![CDATA[用线性时间和常数附加空间将一篇文章的单词（不是字符）倒序]]></question>
		<answer></answer>
		<detail><![CDATA[先将整篇文章的所有字符逆序（从两头起不断交换位置相对称的字符）；然后用同样的办法将每个单词内部的字符逆序。这样，整篇文章的单词顺序颠倒了，但单词本身又被转回来了]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question>设计一个类，我们只能生成该类的一个实例</question>
		<answer></answer>
		<detail><![CDATA[
public class Singleton {

        private static Singleton singleton;

        // 注意点: 私有化构造函数
        private Singleton() {
        }
  
        // synchronized 多线程环境  
        public synchronized static Singleton getInsatnce() {
                if(singleton==null) {
                        singleton = new Singleton();

                }    

                return singleton;
        }   
}
]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question>请实现一个函数，把字符数组中的每个空格替换成"%20"。如"I am javamm",输出为"I%20am%20javamm"</question>
		<answer></answer>
		<detail><![CDATA[
  1. 遍历一次字符串，得到空格的总数,以及数组的总长度

  2. 创建一个新字符数组，长度为原字符串长度 + 空格个数 * 2 

  3. 两个指针，P1指向原字符数组末尾，P2指向新字符数组的末尾  

  4. 移动P1,若非空格，复制至新字符串数组,若为空格，P2插入%20 

分析
  
  时间复制度为O(n)

]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question>从尾到头打印链表</question>
		<answer></answer>
		<detail><![CDATA[
遍历链表至栈中,因为栈为“后进先出”
]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question>输入一个二叉树的前序遍历和中序遍历的结果，请重建出该二叉树(假设不含有重复数字) 。如输入前序遍历{ 1,2,4,7,3,5,6,8} 和中序遍历序列 {4,7,2,1,5,3,8,6}</question>
		<answer></answer>
		<detail><![CDATA[
暂无
]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question>用两个栈实现一个队列</question>
		<answer></answer>
		<detail><![CDATA[
1. 当向队列add数据时，push至栈1
2. 队列取数据时
	若栈2为null,将栈1数据push至栈2中,再从栈2中pop
	若栈2不为null,直接从栈2中pop
]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question>把一个数组的最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的一个旋转，输出旋转数组的最小元素。例如：{3,4,5,1,2} 为{1,2,3,4,5}的一个旋转，最小元素为1</question>
		<answer></answer>
		<detail><![CDATA[
二分查找思想，查找中间元素，找到左边比自己大，右边也比自己大，即为最小元素
]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question>斐波那契数列</question>
		<answer></answer>
		<detail><![CDATA[
暂无
]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question>请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。如输入9,二进制为1001,输出结果为2</question>
		<answer></answer>
		<detail><![CDATA[
把一个整数减1之后，再与原来的整数做位与运算，得到的结果相当于是把整数的二进制表示中的最右边一个1变成0
]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question>求数值的整数次方，不需要考虑大数的问题</question>
		<answer></answer>
		<detail><![CDATA[
// 考查代码完备性
// eg: 当指数为负数，底数为0等
]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question>输入一个数字n,按顺序打印出从1到最大n位的十进制数。如输入3，则打印1,2,3...999</question>
		<answer></answer>
		<detail><![CDATA[
// 当n很大时，会溢出
// 可考虑用字符串表示数字
]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question>给定单向链表的头指针和一个结点指针，定义一个函数在O(1)时间删除结点</question>
		<answer></answer>
		<detail><![CDATA[
把需删除结点的下一个结点内容复制到需删除的结点上，再把下一个结点删除
]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分</question>
		<answer></answer>
		<detail><![CDATA[
1. 维护两个指针，P1指向数组的第一个数字，向后移动; P2指向数组的最后一个数字，向前移动。
2. 在指针相遇前，若P1指向数字是偶数，P2指向数字是奇数，则交换这两个数字
3. 把比较的逻辑部分抽取出来，实现解耦，以满足更多的比较，如把所有的负数放在非负数前面，能被3整除的数放在不能被3整除的数前面
4. 代码扩展性，可重用性
]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question>输入一个单向链表，输出该链表中倒数第k个结点</question>
		<answer></answer>
		<detail><![CDATA[
1. 两个指针P1,P2
2. P1从链表头向前遍历走k-1,P2不变
3. 第k步，P1,P2一起移动，当P1到达尾结点时，P2正好是倒数第k个结点
]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question>如果链表中结点总数为奇数，返回中间结点；如果结点总数是偶数，返回中间两个结点的任意一个</question>
		<answer></answer>
		<detail><![CDATA[
1. 定义两个指针P1,P2
2. 遍历链表，P1走一步，P2走两步，当P2至达末尾时，P1正好在链表的中间
]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question>判断一个单向链表是形成了环形结构</question>
		<answer></answer>
		<detail><![CDATA[
1. 定义两个指针P1,P2
2. 遍历链表，P1走一步，P2走两步，如果走的快的追上了走的慢的，则为环形链表
3. 如果P2走到了链表末尾，仍没有追上P1,则不是环形链表
]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question>定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点</question>
		<answer></answer>
		<detail><![CDATA[
/**
* 为防止链表断开，需要保存结点
* 定义三个指针,PointCurrent,PointPrev,PointNext
*/
public LinkNode reverse(LinkNode linkNode) {
        // 当前节点　
        LinkNode pointCurrent=linkNode;

        // 前一个节点
        LinkNode pointPrev=null;

        // 反转后
        LinkNode resultNode=null;

        while(pointCurrent !=null ) {
                LinkNode pointNext=pointCurrent.next;   
                if(pointNext == null ) {
                        pointCurrent = pointCurrent;
                }

                pointCurrent.next = pointPrev;
                pointPrev=pointCurrent;
                pointCurrent=pointNext;
        }

        return resultNode;
}
]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question>输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的</question>
		<answer></answer>
		<detail><![CDATA[
public LinkNode merge(LinkNode linkNode1,LinkNode linkNode2) {
        if(linkNode1==null) {
                return linkNode2;
        }

        if(linkNode2 ==null ) {
                return linkNode1;
        }

        LinkNode mergedNode = null;
        if(linkNode1.value < linkNode2.value ) {
                mergedNode = linkNode1; 
                mergeNode.next = merge(linkNode1.next,linkNode2);
        }
        else {
                mergedNode = linkNode2;
                mergeNode.next = merge(linkNode1,linkNode2.next);
        }
}

]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question>输入一棵二叉树A和B,判断B是不是A的子结构</question>
		<answer></answer>
		<detail><![CDATA[
public boolean hasSubTree(BinaryNodeTree tree1,BinaryNodeTree tree2 ) { 
        
        boolean result=false;

        if(tree1 != null && tree2 !=null ) {
                if(tree1.value = tree2.value) {
                        result = doesTree1HaveTree2(tree1,tree2);
                }

                if(!result) {
                        result = hasSubTree(tree1.left,tree2);
                }
                if(!result) {
                        result = hasSubTree(tree1.right,tree2);
                }
        }    

        return result;
}
public boolean doesTree1HaveTree2(BinaryNodeTree tree1,BinaryNodeTree tree2) {
        if(tree2 == null ) {
                return true;
        }
        if(tree1 == null ) { 
                return false;
        }
        if(tree1.value != tree2.value ) { 
                return false;
        }

        return doesTree1HaveTree2(tree1.left,tree2.left) && doesTree1HaveTree2(tree1.right,tree2.right);
}

]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question>请完成一个函数，输入一个二叉树，输出它的镜像</question>
		<answer></answer>
		<detail><![CDATA[
/**
* 前序遍历树的每个结点
* 如果遍历到的结点有子结点，则交换子结点
* 当交换完所有非叶子结点的左右子结点后，就得到了树的镜像
*/
public void mirrorRecursively(BinaryTreeNode binaryTreeNode) {
        if(binaryTreeNode==null || (binaryTreeNode.leftNode==null && binaryTreeNode.rightNode==null) ) {
                return;
        }

        BinaryTreeNode tempNode=binaryTreeNode.leftNode;
        binaryTreeNode.leftNode=binaryTreeNode.rightNode;
        binaryTreeNode.rightNode=tempNode;

        // 递归
        mirrorRecursively(binaryTreeNode.leftNode);
        mirrorRecursively(binaryTreeNode.rightNode);
}

]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question>定义栈的数据结构，实现一个得到栈最小值的min函数。使得调用min,push及pop的时间复杂度都为O(1).</question>
		<answer></answer>
		<detail><![CDATA[
思路一：采用辅助栈，将最小值压入辅助栈中
思路二：每一个结点添加最小值的一个属性，此属性保存当前最小值
]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字都不相等。如序列1,2,3,4,5为压>栈序列，序列4,5,3,2,1为该压栈序列对应的一个弹出序列，但4,3,5,1,2不是该压栈序列的弹出序列</question>
		<answer></answer>
		<detail><![CDATA[
/**
* 如果下一个弹出的数字刚好是栈顶数字，直接弹出
* 如果下一个弹出的数字不在栈顶，把压栈序列中还没有入栈的数字压入辅助栈，直到把下一个需要弹出的数字压入栈顶为止
* 如果所有的数字都压入栈了，仍然没有找到下一下弹出的数字，那么该序列不可能是一个弹出序列
*/
]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question>Struts2 是如何把Action交给Spring托管的？它是单例的还是多例？</question>
		<answer></answer>
		<detail><![CDATA[
<constant name="struts.objectFactory" value="spring"/>
若action在struts配置文件中配置，是多例的。但若交给spring管理，因为spring默认为单例，为单例的
]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question>请说一下线程池的中断策略(4个)？ 各有什么特点？</question>
		<answer></answer>
		<detail><![CDATA[
ThreadPoolExecutor中断策略也即饱合策略，线程容器中放不下新的任务了

    JDK提供了4种策略，分别是：

    1、CallerRunsPolicy

    2、AbortPolicy 中止任务，默认，放不下，中上放入新任务

    3、DiscardPolicy 丢弃任务

    4、DiscarOldestPolicy 丢弃最老任务
]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question>请说一下Struts2源代码中有哪些设计模式？</question>
		<answer></answer>
		<detail><![CDATA[
单例模式-- 典型应用： 类：
org.apache.struts2.config.ServletContextSingleton

模版方法模式：
  在org.apache.struts2.components包中大量运用

责任连模式
]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question>一只青蛙一次可以跳上一级台阶，也可以跳上二级台阶，求该青蛙跳上一个n级台阶共有多少种跳法</question>
		<answer></answer>
		<detail><![CDATA[
用递归，同斐波那契数列
]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question>请写出归并排序</question>
		<answer></answer>
		<detail><![CDATA[
package com.javamm.al.sort;

/**
 * 
 * 算法复杂度O(nlogn),冒泡，插入，选择都需要O(n2),若n为10000,n平方100000000，nlogn为40000,若归并需要40s,
 * 则插入排序需要28h 缺点：需要在存储器有另一个大小等于被排序的数据项目的数组,即要足够的空间 思想：归并两个有序的数组
 * 注意：类名请写成MergeSort 
 */
public class MergeSort {

	public static void recSort(int[] data, int left, int right) {

		System.out.println("recSort,left:" + left + " right:" + right);

		if (left == right) {

			return;
		}

		int center = (left + right) / 2;

		// 递归左边
		recSort(data, left, center);

		// 递归右边
		recSort(data, center + 1, right);

		// merge
		merge(data, left, center, right);

	}

	public static void merge(int[] data, int left, int center, int right) {

		System.out.println("merge,left:" + left + " center: " + center
				+ " right: " + right);

		int[] tmpData = new int[data.length];
		int mid = center + 1;
		int third = left;
		int tmp = left;
		while (left <= center && mid <= right) {
			if (data[left] <= data[mid]) {
				tmpData[third++] = data[left++];
			} else {
				tmpData[third++] = data[mid++];
			}
		}

		while (mid <= right) {
			tmpData[third++] = data[mid++];
		}

		while (left <= center) {
			tmpData[third++] = data[left++];
		}

		// 将tmpData中的内容复制回原数组
		while (tmp <= right) {
			data[tmp] = tmpData[tmp++];
		}
	}

	public static void main(String[] args) {

		int[] data = { 3, 2, 1, 6, 0, 8 };

		recSort(data, 0, data.length - 1);

		for (int i = 0; i < data.length; i++) {
			System.out.print(data[i] + " ,");
		}
	}
}
]]></detail>
		<options>
		</options>
	</exam>
	<exam>
		<question>请写出快速排序</question>
		<answer></answer>
		<detail><![CDATA[
/**
* 思想：
*   1. 一躺排序将要排序的数据分成独立的两部分,一部分比另一部分所有数据都小,可用两指针,leftP,rightP，分别指向首尾
*   2. 再按此方法对这两部分数据进行排序,可用递归
*
* 算法复杂度：
*
*  最坏情况算法复杂度：O(n2)，最好O(nlogn)
*/
public class QuickSort {

	private static int[] a;

	public static void main(String[] args) {
		a = new int[] { 5, 3, 2, 1, 8, 4 };
		recQuickSort(0, a.length - 1);
		display();
	}

	public static void recQuickSort(int left, int right) {
		// Step 1 ：把数组划分成左边和右边，左边比选定的值小，右边比选定的值大
		// Step 2 : 递归调用左边
		// Step 3 : 递归调用右边
		if (left >= right) {
			return;
		}

		int pivot = a[right];
		int partition = partitionIt(left, right, pivot);
		recQuickSort(left, partition - 1);
		recQuickSort(partition + 1, right);
	}

	public static int partitionIt(int left, int right, int pivot) {
		display();

		// 左指针
		int leftP = left - 1;

		// 右指针
		int rightP = right;

		while (true) {

			// 左边的值都比pivot小时
			while (a[++leftP] < pivot)
				;

			// 右边的值都比pivot大时
			while (rightP > 0 && a[--rightP] > pivot)
				;

			if (leftP >= rightP) {
				break;
			} else {
				// 交换
				swap(left, right);
			}
		}
		swap(leftP, right);
		return leftP;
	}

	public static void swap(int left, int right) {
		int temp = a[left];
		a[left] = a[right];
		a[right] = temp;
	}

	public static void display() {
		for (int i = 0; i < a.length; i++) {
			System.out.print(a[i] + " ");
		}
		System.out.println("");
	}

}
]]></detail>
		<options>
		</options>
	</exam>
<exam>
		<question><![CDATA[
二叉搜索树排序的缺点
]]></question>
		<answer></answer>
		<detail><![CDATA[
如果树中插入的是随机数据，执行效果很好。但若插入的是有序的，或是逆序的，速度变的很慢
]]></detail>
		<options>
		</options>
	</exam>
<exam>
		<question><![CDATA[
写一个函数，层次遍历二叉树
]]></question>
		<answer></answer>
		<detail><![CDATA[
/**
* 思路：每打印一个结点的时候，如果该结点有子结点，将子结点放入队列末尾
*/
]]></detail>
		<options>
		</options>
	</exam>
<exam>
		<question><![CDATA[
输入一个字符串，打印出该字符串中字符的所有排列。如输入abc,则输出acb,bac,bca,cab,cba
]]></question>
		<answer></answer>
		<detail><![CDATA[
/**
* 将字符串分为两部分，一部分是字符串的第一个字符,另一部分是第一个字符外所有字符
* 用递归 
*/
```
]]></detail>
		<options>
		</options>
	</exam>
<exam>
		<question><![CDATA[
输入一个字符串，打印出该字符串中字符的所有组合。如输入abc,则输出a,b,c,ab,ac,bc,abc,注，ab,ba是不同的排列，但只算一个组合
]]></question>
		<answer></answer>
		<detail><![CDATA[
/**
* 输入n个字符，则能构成长度为1,2,...n的组合
* 求n个字符长度为m的组合的时候，把m个字符分为两部分，第一个和m-1个，递归
*/
]]></detail>
		<options>
		</options>
	</exam>
<exam>
		<question><![CDATA[
输入一个含有8个数字的数组，判断有没有可能这8个数字分别放到正方体的8个顶点上，使得每一面的顶点之和都相等。
]]></question>
		<answer></answer>
		<detail><![CDATA[
/**
* 如输入a1,a2,a3,a4,a5,a6,a7,a8,求所有排列，看是否满足条件，a1+a2+a3+a4==a5+a6+a7+a8,a1+a3+a5+a7=a2+a4+a6+a8,并且a1+a2+a5+a6=a3+a4+a7+a8
*/
]]></detail>
		<options>
		</options>
	</exam>
<exam>
		<question><![CDATA[
数组中有一个数字出现的次数超过了数组长度的一半，请求出这个数字。如{1,2,3,2,2,2,5,4,2},此数字为2
]]></question>
		<answer></answer>
		<detail><![CDATA[
/**
* 思路一：排序，排好序后，求中间数字
* 根据快排思想，先随机选一个数字，使比他小的都排在左边，比他大的都排右边。完成后，若此数字下标为n/2,即为此数。如果下标> n/2,那么此数位于左边,可在左半部查找，用递归。否则位于右边
* 思路二：
* 遍历数组时，保存两个值，一个为数组中数字，一个为次数
* 当遍历下一个数字时，若与保存数字相同，次数+1.若与保存数字不同，次数-1,若次数=0，重新保存新数字，并将次数设为1.最后一次把次数设为1的数字即为所需的数字
* eg: 
* 1,1
* 2,1
* 3,1
* 2,1
* 2,2
* 2,3
* 2,2
* 2,1
* 2,2
*/
]]></detail>
		<options>
		</options>
	</exam>
<exam>
		<question><![CDATA[
给定一个无序整数数组，返回这个数组中第k小的数 
]]></question>
		<answer></answer>
		<detail><![CDATA[
/**
* 思路一：
* 最平常的思路是将数组排序，最快的排序是快排，然后返回已排序数组的第k个数，算法时间复杂度为O（nlogn），空间复杂度为O（1）。使用快排的思想，但是每次只对patition之后的数组的一半递归，这样可以将时间复杂度将为O（n）。

* 具体的思路：将数组按照第一个数字first进行划分，将比first小的放在左边，比first大的放在右边，first放中间。返回patition之后first的下标j。如果此时j+1==k（+1是因为数组下标从0开始）那么说明a[j]就是要找的第k个数。如果j+1<k,递归查找左半部分；如果j+1>k，递归查找右半部分
* 
* 思路二：
* 维持一个大小为k的大顶堆，遍历一次数组，如果数组中的元素比堆顶的元素小，那么就更新堆。最后堆中存放的是数组中的前k小元素。堆顶元素即为要求的第k小个数。

* 这种算法不需要改变原数组结构，但是需要额外维持一个大小为O（k）的堆，时间复杂度为（nlogk）。当k比n小的多的时候，这个算法也是一个很好的选择
/*
]]></detail>
		<options>
		</options>
	</exam>
<exam>
		<question><![CDATA[
输入一个整数型数组，数组中有正数也有负数。数组中一个或连续的多个整数组成一个子数组。求所有子数组的和的最大值
]]></question>
		<answer></answer>
		<detail><![CDATA[
/**
* 思路一：列举数组规律
*   维护一个最大值max
*   若max < 0 ,抛弃
*   若 > max ,更新max
*
* 思路二：动态规划
*   f(i)表示以第i个数字结尾的子数组的最大和,0<=i<n,有如下公式
*     f(i) = data[i], i=0或f(i-1)<=0
*     f(i) = f(i-1) + data[i] i!=0 && f(i-1) > 0
*/
]]></detail>
		<options>
		</options>
	</exam>
<exam>
		<question><![CDATA[
输入一个整数n,求从1到n这n个整数的十进制表示中1出现的次数。eg: 输入12,包含1的数字，1,10,11,12,共出现了5次
]]></question>
		<answer></answer>
		<detail><![CDATA[
暂无
]]></detail>
		<options>
		</options>
	</exam>

<exam>
		<question><![CDATA[
输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。eg输入数组{3,32,321} ,则打印这3个数字排成的最小数字321323
]]></question>
		<answer></answer>
		<detail><![CDATA[
/**
* 思路一：求所有数字的全排列，然后比较大小
*/
]]></detail>
		<options>
		</options>
	</exam>
<exam>
		<question><![CDATA[
我们把只包含因子2，3，5的数称为丑数(ugly number),求按从小到大的顺序的第1500个丑数。eg: 6,8都为丑数，而14不是，因为14含有因子7
]]></question>
		<answer></answer>
		<detail><![CDATA[
解法一：计算每个数，效率不是很高
public boolean isUgly(int number) {
	while(number /2 ==0) {
		number / = 2;
	}
	while(number /3 ==0) {
		number / = 3;
	}
	while(number /3 ==0) {
		number / = 3;
	}

	return (number ==1 ) ? true : false;
}

public int getUglyNumber( int index) {
	if(index < = 0 ) {
		return 0;
	}


	int number = 0;
	int uglyFound = 0;
	while(uglyFound < index ) {
		++number;

		if(isUgly(number) {
			++uglyFound;
		}
	}

	return number;
}

解法二：空间换时间
/**
* M1 M2 M3,若index=1500，需数组大小为6kb
*/
public int getUglyNumber( int index ) {
	if ( index <= 0 ) {
		return 0;
	}

	int [] numbers = new int [index];
	numbers[0] = 1;
	int nextUglyIndex = 1;

	int multiply2 = numbers[0];
	int multiply3 = numbers[0];
	int multiply5 = numbers[0];

	while(nextUglyIndex < index ) {
		int min = min(multiply2 * 2,multiply3 * 3,multiply5 * 5 );	
		numbers[nextUglyIndex]=min;
	}

	while(multiply2 * 2 <= numbers[nextUglyIndex]) {
		++multiply2;
	}
	while(multiply3 * 3 <= numbers[nextUglyIndex]) {
		++multiply3;
	}
	while(multiply5 * 5 <= numbers[nextUglyIndex]) {
		++multiply5;
	}

	++nextUglyIndex;
}
]]></detail>
		<options>
		</options>
	</exam>
<exam>
		<question><![CDATA[
在字符串中找出第一个只出现一次的字符。eg: 输入“abaccdeff“，输出b
]]></question>
		<answer></answer>
		<detail><![CDATA[
/**
* 根据ASCII码值作为数组下标，构造字符Hash
*/
]]></detail>
		<options>
		</options>
	</exam>
<exam>
		<question><![CDATA[
定义一个函数，输入两个字符串，从第一个字符串中删除在第二个字符串中出现过的所有字符。eg: "We are students","aeiou",结果为"W r studnts"
]]></question>
		<answer></answer>
		<detail><![CDATA[
/**
* 构造字符Hash,O（1）时间即可判断是不是在第一个字符串中出现过
*/
]]></detail>
		<options>
		</options>
	</exam>
<exam>
		<question><![CDATA[
定义一个函数，删除字符串中所有重复出现的字符。如输入google,输出为gole
]]></question>
		<answer></answer>
		<detail><![CDATA[
/**
* boolean型的字符hash,当扫描到g时，将g的ascii码103下标的标为true,下次再扫描到g时，即知重复
*/
]]></detail>
		<options>
		</options>
	</exam>
<exam>
		<question><![CDATA[
在英语中，如果两个单词中出现的字母相同，并且每个字母出现的次数也相同，那么这两个单词互为变位词(Anagram),如silent与listen,evil与live, 请完成一个函数，判断输入的两个字符串是不是互为变位词
]]></question>
		<answer></answer>
		<detail><![CDATA[
/**
* 字符hash,扫描第一个字符串，每扫描到一个字符串，对应的值加1，然后再扫描第二个字符串，对应的值-1,最后若hash中的所有的值都为0,那么互为变位词
*/
]]></detail>
		<options>
		</options>
	</exam>
<exam>
		<question><![CDATA[
在数组中的两个数字，如果前面一个数字 > 后面一个数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中逆序对的总数。eg: {7,5,6,4},有5个逆序对，{7,6},{7,5},{7,4},{6,4},{5,4}
]]></question>
		<answer></answer>
		<detail><![CDATA[
/**
* 归并排序
**/
]]></detail>
		<options>
		</options>
	</exam>
<exam>
		<question><![CDATA[
输入两个链表，找出它们的第一个公共结点。
]]></question>
		<answer></answer>
		<detail><![CDATA[
/**
* 链表如果有公共结点，肯定为Y字型，而非X型
* 从后往前比较
* 将链表放入栈中
*/
]]></detail>
		<options>
		</options>
	</exam>
<exam>
		<question><![CDATA[
统计一个数字在排序数组中出现的次数。如输入{1,2,3,3,3,3,4,5}，输入3,则输出为4
]]></question>
		<answer></answer>
		<detail><![CDATA[
/**
* 二分查找，找出3的起始位置和结束位置,时间复杂度为O(logn)
*/
]]></detail>
		<options>
		</options>
	</exam>
<exam>
		<question><![CDATA[
输入一颗二叉树的根结点，求该树的深度
]]></question>
		<answer></answer>
		<detail><![CDATA[
/**
* 树只有一个结点，深度为1
* 若只有左子树，深度为左子树深度 + 1
* 若只有右子树，深度为右子树深度 + 1
* 既有左子树，又有右子树，深度为左子树和右子树中的较大值 + 1
*/
int treeDepth(BinaryTreeNode binaryTreeNode) {
	if(binaryTreeNode == null ) {
		return 0;
	}

	int leftDepth=treeDepth(binaryTreeNode.left);
	int rightDepth=treeDepth(binaryTreeNode.right);
	return (leftDepth > rightDepth) ? (leftDepth+1):(rightDepth+1);
}
]]></detail>
		<options>
		</options>
	</exam>
<exam>
		<question><![CDATA[
输入一颗二叉树的根结点，判断该树是不是平衡二叉树.如果某二叉树中任意结点的左右子树的深度相差不超过1，那么它就是一颗平衡二叉树
]]></question>
		<answer></answer>
		<detail><![CDATA[
/**
* 后序遍历
* 递归求出左子树，右子树深度
* 对深度进行比较
*/
]]></detail>
		<options>
		</options>
	</exam>
<exam>
		<question><![CDATA[
一个整数数组中除了两个数字外，其它数字都出现了两次，请找出这两个只出现了一次的数字。要求时间复杂度是O(n),空间复杂度是O(1)
]]></question>
		<answer></answer>
		<detail><![CDATA[
/**
* 任何一个数字异或它自己都等于０
* eg: {2,4,3,6,3,2,5,5}，异或得到的结果为0010，把数组拆分，按照倒数第二位是不是1，会拆分为{2,3,6,3,2}和{4,5,5}，再求异或即可得到结果
*/
]]></detail>
		<options>
		</options>
	</exam>
<exam>
		<question><![CDATA[
输入一个递增排序的数组和一个数字s,在数组中查找两个数，使它们的和正好为s。如果有多对数字的和等于s，输出任意一对即可。eg：输入{1,2,4,7,11,15}和15，输出为{4,11}
]]></question>
		<answer></answer>
		<detail><![CDATA[
/**
* 定义两个指针，headPoint,tailPoint
* 若data[headPoint] + data[tailPoint] > 15 ,tailPoint --
* 若data[headPoint] + data[tailPoint] < 15 ,headPoint ++
**/
]]></detail>
		<options>
		</options>
	</exam>
<exam>
		<question><![CDATA[
输入一个正数s，打印出所有和为s的连续正数序列（至少包含两个数)。如输入15，则输出为{1,2,3,4,5}，{4,5,6},{7,8}
]]></question>
		<answer></answer>
		<detail><![CDATA[
/**
* 定义两个指针，firstPoint=0,secondPoint=1
* 若data[firstPoint} +...+ data[secondPoint] < 15 secondPoint ++; 
* 若data[firstPoint} +...+ data[secondPoint] > 15 firstPoint ++; 
* 以输入9为例：
* 1 + 2 < 9 
* 1 + 2 + 3 <9
* 1 + 2 + 3 + 4 > 9
* 2 + 3 + 4 = 9
* 2 + 3 + 4 + 5 > 9
* 3 + 4 + 5 >9
* 4 + 5 = 9
**/
]]></detail>
		<options>
		</options>
	</exam>
<exam>
		<question><![CDATA[
输入一个英文句子，翻转句子中单词的顺序，但单词内的顺序不变，标点符号和字母一样处理。eg: "I am a student." 输出为"student. a am I"
]]></question>
		<answer></answer>
		<detail><![CDATA[
/**
* 1. 翻转所有字符，得到".tneduts a ma I"
* 2. 翻转每个单词中字符的顺序
* 3. 用指针
**/
]]></detail>
		<options>
		</options>
	</exam>
<exam>
		<question><![CDATA[
字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。实现一个函数实现字符串左旋转操作的功能。eg 输入"abcdefg"和2，则结果为"cdefgab"
]]></question>
		<answer></answer>
		<detail><![CDATA[
/**
* 先翻转成 ba + gfedc
* 再翻转bagfedc，即得cdefgab
*/
]]></detail>
		<options>
		</options>
	</exam>
<exam>
		<question><![CDATA[
把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，输出s的概率
]]></question>
		<answer></answer>
		<detail><![CDATA[
/**
* 总数为6的n次方
* 解法一：递归 f(1) 有6种可能 f(n) = s - f(n-1)
**/
]]></detail>
		<options>
		</options>
	</exam>
<exam>
		<question><![CDATA[
从扑克牌中随机抽5张牌，判断是不是一个顺子。A为1,J为11,Q为12,K为13。大小王可看成任意数字
]]></question>
		<answer></answer>
		<detail><![CDATA[
/**
* 将大小王看成数字0
* 排序
* 统计0的个数以及相邻数字间空缺总数
* 重复出现，数组不是连续的
*/
]]></detail>
		<options>
		</options>
	</exam>
<exam>
		<question><![CDATA[
0,1,...,n-1这n个数字排成一个圆圈，从数字0开始每次从这个圆圈里删除第m个数字，求这个圆圈里剩下的最后一个数字
]]></question>
		<answer></answer>
		<detail><![CDATA[
/**
* 约瑟夫环
* 解法一：环形链表 时间复杂度O(mn)
* 解法二：f(n,m) = 0 (n = 1) f(n,m)=[f(n-1,m) + m] % n (n>1)
*/
]]></detail>
		<options>
		</options>
	</exam>
<exam>
		<question><![CDATA[
求1+2+...+n,要求不能使用乘除法，for,while,if,else,switch,case,a?b:c
]]></question>
		<answer></answer>
		<detail><![CDATA[
暂无
]]></detail>
		<options>
		</options>
	</exam>
<exam>
		<question><![CDATA[
写一个函数，求两个整数之和，要求在函数体内不得使用+ - * /
]]></question>
		<answer></answer>
		<detail><![CDATA[
/**
* 1. 各位相加不进位，异或
* 2. 考虑进位，与运算
* 3. 将前面两个数相加,即重复1,2,直到不产生进位为止
*/
]]></detail>
		<options>
		</options>
	</exam>
<exam>
		<question><![CDATA[
输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。假设数组中任意两个数字不同。
]]></question>
		<answer></answer>
		<detail><![CDATA[
/**
* {5,7,6,9,11,10,8 } 8为根结点 ,5,7,6比8小，9,11,10比8大
* 递归子结构
*/
]]></detail>
		<options>
		</options>
	</exam>
<exam>
		<question><![CDATA[
用shell分析Apache日志(/usr/local/apache2/logs/access_log)，要求列出当天访问次数最多20个IP
]]></question>
		<answer></answer>
		<detail><![CDATA[
cut -d- -f 1 /usr/local/apache2/logs/access_log |uniq -c | sort -rn | head -20
]]></detail>
		<options>
		</options>
	</exam>
<exam>
		<question><![CDATA[
什么时候才要建索引,什么时候不要建索
]]></question>
		<answer></answer>
		<detail><![CDATA[
* 如果每次都需要取到所有表记录，无论如何都必须进行全表扫描了，那么是否加索引也没有意义了。
* 对非唯一的字段，例如“性别”这种大量重复值的字段，增加索引也没有什么意义。
* 对于记录比较少的表，增加索引不会带来速度的优化反而浪费了存储空间，因为索引是需要存储空间的,而且有个致命缺点是对于update/insert/delete的每次执行，字段的索引都必须重新计算更新 

]]></detail>
		<options>
		</options>
	</exam>
</exams>
